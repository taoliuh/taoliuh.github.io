<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>So Naive</title>
  
  
  <link href="http://sonaive.me/atom.xml" rel="self"/>
  
  <link href="http://sonaive.me/"/>
  <updated>2020-12-27T14:42:29.000Z</updated>
  <id>http://sonaive.me/</id>
  
  <author>
    <name>So Naive</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我的Android应用架构设计演进之路</title>
    <link href="http://sonaive.me/2020/12/12/the-evolution-of-design-patterns/"/>
    <id>http://sonaive.me/2020/12/12/the-evolution-of-design-patterns/</id>
    <published>2020-12-12T07:00:33.000Z</published>
    <updated>2020-12-27T14:42:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在思考做一个Android架构设计的分享，主要目的是通过回顾架构设计的演进过程，帮助我们审查和改进当前工程设计中的一些缺陷。</p><p>说起Android架构设计，马上就会有熟悉的几个词蹦出来，MVC, MVP, MVVM, 这些架构设计的内涵是什么？有优劣之分吗？除了它们，还有哪些架构设计模式？</p><p>为了回答上面的问题，我从自己的项目架构演进来分别说明一下各种架构设计的特点。我们今天讨论的都是构建用户交互应用程序的架构设计，是细粒度功能模块代码组织与划分，组件化，插件化等工程模块的拆分不在讨论范围之内。</p><a id="more"></a><h3 id="一、MVC的内涵"><a href="#一、MVC的内涵" class="headerlink" title="一、MVC的内涵"></a>一、MVC的内涵</h3><p>做移动客户端开发，无论Android还是iOS, MVC都是大家最熟悉的一种架构设计模式。M指Model层，职责是数据存取，V指View层，职责是展示数据到View, C指Controller层，负责具体的业务逻辑，隔离Model与View, 外部触发Controller通过Model获取到数据后，通知View更新数据，起到了连接Model与View的桥梁作用。</p><p>映射到Android中，Activity, Fragment对应什么角色，承担的职责是什么？</p><p>先不急着回答这个问题，回想下在我们开始写Android应用，还没有架构设计概念时，了解了Activity是干什么的之后，让Activity完成所有的事情。在Activity发起网络请求，开启一个子线程或者AsyncTask, 获取响应结果后显示数据内容。</p><img data-src="/assets/img/android-design-patterns-bad-way.png" class="" title="[The Incorrect Implementation of Design Patterns]"><p>上图展示的是一种最原始的代码组织方式，随着业务的扩展，Activity里会遍布各种业务逻辑，同时要处理与生命周期有关的回调，Activity会变得越来越臃肿。一不小心，没处理好对象在生命周期方法里释放造成内存泄漏也是家常便饭。趁着代码还没到臃肿腐烂到难以重构之前，我们先重构一版吧。</p><p>将Activity, Fragment作为一个控制器Controller.</p><h4 id="Controller控制器-amp-View"><a href="#Controller控制器-amp-View" class="headerlink" title="Controller控制器&amp;View"></a>Controller控制器&amp;View</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">FragmentActivity</span> <span class="keyword">implements</span> <span class="title">ResponseListener</span>&lt;<span class="title">Weather</span>&gt;, <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WeatherModel mWeatherModel;</span><br><span class="line">    <span class="keyword">private</span> EditText mCityNOInput;</span><br><span class="line">    <span class="keyword">private</span> TextView mCity;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mWeatherModel = <span class="keyword">new</span> WeatherModelImpl();</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化View</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mCityNOInput = findViewById(R.id.et_city_no);</span><br><span class="line">        mCity = findViewById(R.id.tv_city);</span><br><span class="line">        ...</span><br><span class="line">        findView(R.id.btn_go).setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayResult</span><span class="params">(Weather weather)</span> </span>&#123;</span><br><span class="line">        city.setText(weather.getCity());</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.btn_go:</span><br><span class="line">                mWeatherModel.getWeather(cityNOInput.getText().toString().trim(), <span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Weather weather)</span> </span>&#123;</span><br><span class="line">        displayResult(weather);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, 获取天气信息失败, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Model模型"><a href="#Model模型" class="headerlink" title="Model模型"></a>Model模型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WeatherModel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getWeather</span><span class="params">(String cityNumber, ResponseListener&lt;Weather&gt; listener)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResponseListener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(T response)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherModelImpl</span> <span class="keyword">implements</span> <span class="title">WeatherModel</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getWeather</span><span class="params">(String cityNumber, <span class="keyword">final</span> ResponseListener&lt;Weather&gt; listener)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        VolleyRequest.newInstance().newGsonRequest(<span class="string">&quot;http://www.weather.com.cn/data/sk/&quot;</span> + cityNumber + <span class="string">&quot;.html&quot;</span>,</span><br><span class="line">                Weather.class, <span class="keyword">new</span> Response.Listener&lt;weather&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Weather weather)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (weather != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            listener.onSuccess(weather);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            listener.onError();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="keyword">new</span> Response.ErrorListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span> </span>&#123;</span><br><span class="line">                        listener.onError();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看着是分层了，Activity轻了很多，但是依然承担了多个职责，既想当View, 又想立控制器，违背了设计模式的单一职责原则。即使只让Activity作为一个View, 它依然不是一个纯粹的View. Activity或者Fragment承担了系统赋予的一些职责，Fragment的管理及通信，生命周期回调的入口，这些是没办法避免的，只能让其承担的额外职责更少。</p><p>这是我们下一步优化的方向，从Activity中抽出Controller层，负责业务逻辑，Activity只负责View层显示及生命周期、Fragment管理。</p><img data-src="/assets/img/android-design-patterns-mvc.png" class="" title="[Design Patterns Of MVC]"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IWeatherView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showWeather</span><span class="params">(Weather weather)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showError</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;IWeatherView&gt; mWeatherViewRef;</span><br><span class="line">    <span class="keyword">private</span> WeatherModel mWeatherModel;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherController</span><span class="params">(IWeatherView view)</span> </span>&#123;</span><br><span class="line">    mWeatherViewRef = <span class="keyword">new</span> WeakReference&lt;&gt;(view);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getWeather</span><span class="params">(String cityNumber)</span> </span>&#123;</span><br><span class="line">        mWeatherModel.getWeather(cityNumber, <span class="keyword">new</span> ResponseListener&lt;Weather&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Weather response)</span> </span>&#123;</span><br><span class="line">                IWeatherView weatherView = mWeatherViewRef.get();</span><br><span class="line">                <span class="keyword">if</span> (weatherView == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    weatherView.showWeather(response);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                IWeatherView weatherView = mWeatherViewRef.get();</span><br><span class="line">                <span class="keyword">if</span> (weatherView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    weatherView.showError();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">FragmentActivity</span> <span class="keyword">implements</span> <span class="title">IWeatherView</span>,  <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WeatherController mWeatherController;</span><br><span class="line">    <span class="keyword">private</span> EditText mCityNOInput;</span><br><span class="line">    <span class="keyword">private</span> TextView mCity;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mWeatherController = <span class="keyword">new</span> WeatherController(<span class="keyword">this</span>);</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化View</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mCityNOInput = findViewById(R.id.et_city_no);</span><br><span class="line">        mCity = findViewById(R.id.tv_city);</span><br><span class="line">        ...</span><br><span class="line">        findViewById(R.id.btn_go).setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (view.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.btn_go:</span><br><span class="line">                mWeatherController.getWeather(mCityNOInput.getText().toString().trim());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWeather</span><span class="params">(Weather weather)</span> </span>&#123;</span><br><span class="line">        mCity.setText(weather.getCity());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;获取天气信息失败&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>既然Activity承担视图更新的职责，索性把UI逻辑抽象成接口，面向接口编程，Activity实现IWeatherView接口，只关注实现UI逻辑，当业务扩展到一定程度，我们要把这部分UI转为Fragment实现时，也可以快速重构。Activity可以只关注生命周期事件和管理Fragment.</p><p>架构分层的目的是为了解耦，目前的架构实现了Model与View的真正分离，修改View而不影响Model. 在工程实践中，也会发现一些缺点，如果一个Controller承担业务比较重，同样会造成Controller的臃肿，解决的办法也很简单，及时拆分多个Fragment, 对应拆分Controller. </p><p>有的同学会觉得这不就是MVP架构吗？只不过名字叫Controller而已。没错，如今流行的MVP也是从MVC延伸发展出来的。</p><p>在MVP里，各自层级的职责和依赖关系和MVC其实是一样的，但不同的是，MVP之间的交互主要是通过接口实现的，Model、View、Presenter都有各自的接口，定义各自的行为方法。针对接口编程，自然就能降低耦合。至于其他优点，提高复用性、更容易进行单元测试我们不去深究，因为在实际开发过程中单个feature业务基本没有复用的机会，有段时间我甚至参考了Clean架构把业务划分成了更细粒度的UseCase, 为了实现最大程度的复用，然而并没有什么用，根本用不上。如果需要写业务单元测试代码，推荐学习下google的<a href="https://github.com/android/architecture-samples/tree/todo-mvp-rxjava">architecture-samples</a>项目。</p><h3 id="二、由缓存引入的Loader框架"><a href="#二、由缓存引入的Loader框架" class="headerlink" title="二、由缓存引入的Loader框架"></a>二、由缓存引入的Loader框架</h3><p>MVC, MVP定义了更多的接口，让我们面向接口编程而不是面向实现编程，进一步降低了耦合。但是Activity, Fragment生命周期时短暂的，系统配置发生变化，横竖屏变换，退回到后台被系统结束掉Activity后如何快速恢复当前的状态，这是我们不能回避的问题。</p><p>因为没有做好数据持久化，保存现场数据，没有考虑Activity销毁重建的问题，在打开开发者模式的保留单个活动时，使用应用很可能就会导致崩溃。</p><p>如何在Activity出现异常结束时保留现场数据？<br>Activity从API level 1就引入了保存和恢复现场数据的方法，onSaveInstanceState用于在onStop生命周期回调前保存Activity数据，onCreate方法中的Bundle参数savedInstanceState用于现场恢复，由ActivityManager进行管理，但受制于Binder数据传输大小的限制，只能保存不超过50K大小数据量的数据。<br><a href="https://yishengma.github.io/2019/03/29/Android-onSaveInstanceState-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%99%90%E5%88%B6%E4%BA%86%E5%A4%A7%E5%B0%8F%EF%BC%9F/">onSaveInstanceState 的数据存在哪里？为什么限制了大小？</a></p><p>这显然不能用于保存业务数据，Activity恢复时还需要再次加载数据，如果没有内存缓存，数据库缓存，从网络加载时会相对较慢，不是最好的用户体验。我们都使用过新闻类、视频类应用，比如百度APP, 爱奇艺首页有10多个栏目，可以通过左右划切换tab, 划到一个tab时就会触发网络请求，当还未收到响应数据的时候，如果切换到新的tab, 那么上一个tab页面的请求响应结果如何处理？丢弃，渲染，缓存？</p><p>对于排队中的请求，可以使用丢弃策略。渲染一个非可见的页面很可能会和其他页面渲染造成撞车，造成渲染卡顿等问题。更好的做法是工作线程中缓存数据，待回到页面时候进行渲染。</p><p>加入了缓存之后，有两种数据加载和缓存策略。<br>第一种策略：数据加载时先从缓存加载，缓存中无数据再从网络加载。从网络加载完成后，post到主线程渲染的同时缓存数据。<br>第二种策略：数据统一先入库，监听数据库发生变化时主动加载。</p><p>第一种策略可能大家比较熟知，对比起来第二种显得非主流一些。为什么选择第二种策略，起源于2010年Google I/O大会的一场演讲，主题是开发Android REST客户端应用程序。提到了三种架构设计模式，我使用了第三种，通过SyncAdapter与ContentProvider去同步数据的方式，我在看到这个演讲的时候大概是2014年底，接触到Google官方推荐的架构设计概念已经非常滞后了。这个演讲并没有提供什么源码参考，后来我按照这个设计实现了一个v2ex客户端（v2ex.com提供了访问网站数据的API）。</p><p><a href="https://www.youtube.com/watch?v=xHXn3Kg2IQE">Google I/O 2010 - Android REST client applications</a><br><a href="https://github.com/taoliuh/v2ex">v2ex android client Github</a></p><img data-src="/assets/img/sync_adapter_and_content_provider_implement.png" class="" title="[The SyncAdapter and ContentProvider Implementation]"><p>SyncAdater是Android提供的数据同步框架，即使应用没有启动，framework也可以启动Service创建SyncAdater, 在后台根据网络连接、失败重试等不同条件下自动、周期性地同步数据，也可以设置强制立即执行数据同步。在这里我将它设置为立即同步数据，启动SyncAdapter进行数据同步时，会开启一个线程，网络耗时操作可以放到子线程回调任务中onPerformSync方法中执行，任务结束后线程自动结束。这也引入了一个问题，单线程模型无法支持多并发，也是后期抛弃SyncAdapter同步数据的一个原因。</p><p>获取到数据之后，通过Processor处理数据，组合ContentProvider batch操作，最终将数据保存到数据库中。当数据库内容发生变化时，监听uri触发CursorLoader重新加载数据，最终通过LoaderCallbacks回调onLoadFinished完成数据加载。值得一提的是，SyncAdapter(继承自AbstractThreadedSyncAdapter), ContentProvider, CursorLoader都是Android提供的API, SyncAdapter实现数据请求加载，ContentProvider实现数据存取，CursorLoader和Activity生命周期完美匹配，当Activity因为系统配置发生变化销毁重建时，Loader之前加载的数据并不会丢失，一旦Activity/Fragment被永久销毁，Loader也会随之被清理，也就意味着Loader不会再Activity/Fragment被销毁后继续加载数据，增加App负担。</p><p>这些优势是系统管理的LoaderManager帮我们实现的，LoaderManager关注Activity/Fragment的生命周期状态，并管理着多个Loader实例。到目前为止，基于SyncAdapter + ContentProvider + CurorLoader的架构已经实现了业务逻辑和UI逻辑的解耦，Loader与Activity生命周期的绑定又把我们从生命周期回调中要做的善后工作解放出来了，即使系统配置发生变化，数据也不会丢失。</p><p>基于这个架构，我完成了3个小型项目，在当时我觉得是一种不错的架构。但是也有很明显的缺点，比如前面提到的SyncAdapter运行时开启一个线程，任务执行完毕关闭线程不适合多线程并发的场景；所有的网络操作最后都要通过更新数据库表来通知页面更新，显得比较重，进而带来的是开发效率的降低。</p><h3 id="三、更灵活轻量的基于Loader的架构"><a href="#三、更灵活轻量的基于Loader的架构" class="headerlink" title="三、更灵活轻量的基于Loader的架构"></a>三、更灵活轻量的基于Loader的架构</h3><p>系统提供的CursorLoader只能从数据库加载数据，可以通过继承AsyncTaskLoader来实现基于内存缓存的数据存取框架，既保留Loader的优点，又满足线程并发的需求和降低对数据库的依赖。</p><p>于是，在上面框架的基础上，衍生发展了完全基于Loader的架构。</p><img data-src="/assets/img/the_loader_based_implemet.png" class="" title="[The Loader Based Implementation]"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteResourceLoader</span>&lt;<span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Loader</span>&lt;<span class="title">Result</span>&lt;<span class="title">R</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">ILoadListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isLoading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isFirstPageDataExist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Notifiable mNotifiable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasDelivered;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RemoteResourceLoader</span><span class="params">(Context context, Notifiable notifiable)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(context);</span><br><span class="line"><span class="keyword">this</span>.mNotifiable = notifiable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLoading</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> isLoading;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNotifiable</span><span class="params">(Notifiable notifiable)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.mNotifiable = notifiable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">reload</span><span class="params">(Object... params)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(isLoading) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">hasDelivered = <span class="keyword">false</span>;</span><br><span class="line">onForceLoad();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadNextPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">reload();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onForceLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(isLoading || hasDelivered) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> WorkTask().execute();</span><br><span class="line"><span class="keyword">super</span>.onForceLoad();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStartLoading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">forceLoad();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStopLoading</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resetFirstPageDataExist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">isFirstPageDataExist = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Result&lt;R&gt; <span class="title">createResult</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Integer</span>, <span class="title">Result</span>&lt;<span class="title">R</span>&gt;&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">isLoading = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mNotifiable != <span class="keyword">null</span>) &#123;</span><br><span class="line">mNotifiable.onLoadStart(isFirstPageDataExist);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Result&lt;R&gt; <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>&#123;</span><br><span class="line">Result&lt;R&gt; result = createResult();</span><br><span class="line"><span class="keyword">if</span>(!isFirstPageDataExist) &#123;</span><br><span class="line">isFirstPageDataExist = result.isDataValid();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Result&lt;R&gt; result)</span> </span>&#123;</span><br><span class="line">isLoading = <span class="keyword">false</span>;</span><br><span class="line">deliverResult(result);</span><br><span class="line">stopLoading();</span><br><span class="line">hasDelivered = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mNotifiable != <span class="keyword">null</span>) &#123;</span><br><span class="line">mNotifiable.onLoadStop(isFirstPageDataExist, result.getCode(), result.getError());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mCode;</span><br><span class="line"><span class="keyword">private</span> String mError;</span><br><span class="line"><span class="keyword">private</span> R mResult;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Result</span><span class="params">(<span class="keyword">int</span> code, String error, R result)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.mCode = code;</span><br><span class="line"><span class="keyword">this</span>.mError = error;</span><br><span class="line"><span class="keyword">this</span>.mResult = result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">mCode = code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResult</span><span class="params">(R result)</span> </span>&#123;</span><br><span class="line">mResult = result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setError</span><span class="params">(String error)</span> </span>&#123;</span><br><span class="line">mError = error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getError</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mError;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isDataValid</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Notifiable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开始载入数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hasFirstPageData 第一页数据是否存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoadStart</span><span class="params">(<span class="keyword">boolean</span> hasFirstPageData)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 载入过程停止</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoadStop</span><span class="params">(<span class="keyword">boolean</span> hasFirstPageData, <span class="keyword">int</span> code, String error)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ILoadListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoadNextPage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仿照AsyncTaskLoader的实现，内部工作线程使用AsyncTask, 并从外部传入Notifiable对象，Notifiable是一个接口，主要用于更新View开启加载loading和停止loading. Result封装了结果和错误提示。对象的创建createResult和加载策略及动态加载下一页数据留给RemoteResourceLoader的子类去实现。</p><p>RemoteResourceLoader各个子类完成业务逻辑的封装，在LoaderManager的加持下，实现了业务逻辑和UI逻辑的完全独立，进而到达业务逻辑的复用。基于不同场景，自定义Loader, 比如加载信息流，可以继承RemoteResourceLoader实现网络加载及缓存的管理；按钮点赞可以继承AsyncTaskLoader实现网络操作，不考虑缓存管理；从数据库加载联系人则可以使用系统提供的CursorLoader. </p><p>当手机状态发生改变比如旋转时，Activity会重新启动，Loader却不会销毁，只有当Activity/Fragment被永久销毁时才会清除Loader.</p><p>Loader的生命周期是是由系统控制的，在手机状态改变时不会被销毁，只有当Activity/Fragment被永久销毁时才清除Loader. 那么是否可以通过Loader的特性去保持Presenter不被销毁，特别是当Presenter保存了业务数据，在Activity销毁重建时维持一个Presenter更有用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PresenterLoader</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Presenter</span>&gt; <span class="keyword">extends</span> <span class="title">Loader</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PresenterFactory&lt;T&gt; factory;</span><br><span class="line">    <span class="keyword">private</span> T presenter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStartLoading</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we already own an instance, simply deliver it.</span></span><br><span class="line">        <span class="keyword">if</span> (presenter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            deliverResult(presenter);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Otherwise, force a load</span></span><br><span class="line">        forceLoad();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onForceLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create the Presenter using the Factory</span></span><br><span class="line">        presenter = factory.create();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Deliver the result</span></span><br><span class="line">        deliverResult(presenter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onReset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        presenter.onDestroyed();</span><br><span class="line">        presenter = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Presenter</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onViewAttached</span><span class="params">(V view)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onViewDetached</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDestroyed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Activity销毁时，自动触发Presenter执行onDestroyed()方法，我们可以在这个方法里去做必要的资源释放。</p><p><a href="https://medium.com/@czyrux/presenter-surviving-orientation-changes-with-loaders-6da6d86ffbbf">Presenter surviving orientation changes with Loaders</a></p><h3 id="四、MVVM模式"><a href="#四、MVVM模式" class="headerlink" title="四、MVVM模式"></a>四、MVVM模式</h3><p>从前面的架构设计一路走来，逐步解决了层级的划分去除Activity/Fragment的臃肿，业务和UI逻辑的解耦，系统配置变化保持业务数据。MVVM的出现又能帮我们解决哪些问题？</p><p>虽然MVP中Presenter没有直接持有View层的实例，但是还是持有了View层的接口，在开发过程中我们还需要处理生命周期相关的问题，一旦处理不好，就会造成内存泄漏，例如Activity已经销毁了，还在通知View去更新UI，这样跟容易造成内存泄漏。</p><p>而在MVVM中，ViewModel是不会持有任何View层引用的，也就是说ViewModel是完全跟View层分离的，耦合度更低，且更容易复用代码，配合RxJava, AutoDispose我们无需处理生命周期相关的逻辑，有效的避免了内存泄漏问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在思考做一个Android架构设计的分享，主要目的是通过回顾架构设计的演进过程，帮助我们审查和改进当前工程设计中的一些缺陷。&lt;/p&gt;
&lt;p&gt;说起Android架构设计，马上就会有熟悉的几个词蹦出来，MVC, MVP, MVVM, 这些架构设计的内涵是什么？有优劣之分吗？除了它们，还有哪些架构设计模式？&lt;/p&gt;
&lt;p&gt;为了回答上面的问题，我从自己的项目架构演进来分别说明一下各种架构设计的特点。我们今天讨论的都是构建用户交互应用程序的架构设计，是细粒度功能模块代码组织与划分，组件化，插件化等工程模块的拆分不在讨论范围之内。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Android Architecture Components源码分析</title>
    <link href="http://sonaive.me/2018/11/21/android-architecture-components-analysis/"/>
    <id>http://sonaive.me/2018/11/21/android-architecture-components-analysis/</id>
    <published>2018-11-21T07:05:10.000Z</published>
    <updated>2018-12-08T10:15:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>在分析Android Architecture Component这个框架之前，先想想这个框架能为我们做什么，我们为什么要按照这套框架模式去构建app？它和MVP架构有什么区别？</p><p>MVP, Clean, AAC架构的特点：<br>MVP架构的特点是面向接口编程。在View, Presenter, Model之间分别用接口做衔接，当有新的底层实现时，能够无缝替换。</p><p>此外，MVP的View和Model并不产生依赖，因此可以说是对View和Model做了解耦。</p><p>但MVP架构有其局限性。MVP需要创建太多的类和接口,并且每次通信都需要繁琐的通过接口传递信息</p><p>google sample提供了一个todo-mvp sample, 里面有MVP+RxJava实现，Clean架构实现。这两种架构方式我都实践过，MVP+RxJava所有业务,UI逻辑都包含在Presenter里面, Presenter直接干预了UI在拿到数据后做什么，使得逻辑上没有发生解耦，正常来说，解耦意味着Presenter的只能边界仅限返回结果数据，由UI来根据数据处理UI逻辑。</p><a id="more"></a><p>Clean架构将业务逻辑分解成可重用的更小粒度的usecase, 业务逻辑的职能被转移到领域层，Presenter则弱化为ViewModel, 作为代理数据请求和衔接数据回调的缓冲区。</p><p>Clean 架构的特点是单向依赖、数据驱动编程。 View -&gt; ViewModel -&gt; Usecase -&gt; Model.</p><p>但 Clean 架构也有不足：粒度太细 。一个 Usecase 受限于请求参数，因而只能处理一类请求。View请求求的数据包含几种类型，就至少需要准备几个 Usecase。Usecase是依据当前View对数据的需求量身定制的，且形式大同小异，因此Usecase的复用率极低，项目会因而急剧的增加类和重复代码。</p><p>AAC也是数据驱动编程。直接在View中写个观察者回调，以接收结果数据并处理UI逻辑。MVP架构中Presenter直接引用View，告诉View该显示什么，而AAC中的View持有ViewModel的引用，ViewModel不需要持有View的引用，而是根据View绑定的事件进行流式调用，这也意味着MVP架构中以来的回调接口也用不着了。</p><p>数据的消费者应该知道生产者，但生产者（ViewModel）不知道也不关心谁消费了数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribeUi</span><span class="params">(ProductListViewModel viewModel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Update the list when the data changes</span></span><br><span class="line">    viewModel.getProducts().observe(<span class="keyword">this</span>, <span class="keyword">new</span> Observer&lt;List&lt;ProductEntity&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(<span class="meta">@Nullable</span> List&lt;ProductEntity&gt; myProducts)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (myProducts != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mBinding.setIsLoading(<span class="keyword">false</span>);</span><br><span class="line">                mProductAdapter.setProductList(myProducts);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mBinding.setIsLoading(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// espresso does not know how to wait for data binding&#x27;s loop so we execute changes</span></span><br><span class="line">            <span class="comment">// sync.</span></span><br><span class="line">            mBinding.executePendingBindings();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，Fragment.setRetainInstance(boolean retain<br>)方法设置为true, 保证Configuration change的时候与该fragment关联的数据能够保存。</p><p>AAC是由一系列库组成，能够帮助我们管理UI组件的生命周期和处理数据存留。生命周期感知组件可以管理Activity和Fragment的生命周期，在configuration change的时候可以保留现场数据并重新更新UI，避免内存泄漏。</p><p>使用LiveData构造数据对象，当底层数据发生变化时就会通知更新UI.</p><p>ViewModel存储UI相关的数据，在app旋转时不会销毁。</p><p>Lifecycle如何与Activity, Fragment的生命周期绑定？<br>Lifecycle定义了一个拥有Android生命周期的对象，Activity, Fragment实现了LifecycleOwner接口，可以直接访问到Lifecycle.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lifecycle定义了两个枚举类型Event和State, State可以看做图的节点，State定义了一系列与生命周期相关的状态，Event则可以看做图的路径。Lifecycle负责保存并更新当前生命周期状态。</p><p>刚好在Activity.onDestroy()调用之前，达到DESTROYED状态，处于DESTROYED状态的Lifecycle对象不会再传递任何事件Event.</p><p>INITIALIZED状态在Lifecycle对象已创建但还未调用Activity.onCreate()之前。</p><p>在Activity.onCreate()调用之后，Activity.onStop()调用之前处于CREATED状态。</p><p>在Activity.onStart()调用之后，Activity.onPause()调用之前处于STARTED状态。</p><p>在Activity.onResume()调用之后处于RESUMED状态。</p><p>接下来看看状态的转化。</p><p>什么时候处于INITIALIZED状态呢？</p><p>首先来看一下生命周期感知组件的类关系图<br><img data-src="https://github.com/taoliuh/taoliuh.github.io/blob/master/assets/img/Lifecycle.jpg?raw=true"></p><p>Lifecycle定义成一个拥有Android生命周期的接口对象。Fragment或FragmentActivity实现了LifecycleOwner接口，并通过getLifecycle方法获取LifecycleRegistry对象。LifecycleRegistry实现了Lifecycle，能够处理多个观察者。</p><p>LifecycleRegistry定义了内部嵌套类ObserverWithState，通过调用addObserver方法我们将参数LifecycleObserver对象传入，并封装成了ObserverWithState对象，在handleLifecycleEvent接收到外部传入的Event事件，计算出目标状态，最后调用GenericLifecycleObserver的onStateChanged方法通知状态的变换。</p><p><img data-src="https://raw.githubusercontent.com/taoliuh/taoliuh.github.io/master/assets/img/LifecycleSeq.jpg"><br>当应用程序启动时，会注册清单文件里声明的ContentProvider, 在框架里就是ProcessLifecycleOwnerInitializer, 可以到app/build/outputs/logs/manifest-merge-debug-report.txt找到ProcessLifecycleOwnerInitializer类所在的清单文件位置，最终清单文件会合并到打包完成的应用中来。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    <span class="keyword">package</span>=<span class="string">&quot;androidx.lifecycle.process&quot;</span> &gt;</span><br><span class="line"></span><br><span class="line">    &lt;uses-sdk android:minSdkVersion=<span class="string">&quot;14&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;application&gt;</span><br><span class="line">        &lt;provider</span><br><span class="line">            android:name=<span class="string">&quot;androidx.lifecycle.ProcessLifecycleOwnerInitializer&quot;</span></span><br><span class="line">            android:authorities=<span class="string">&quot;$&#123;applicationId&#125;.lifecycle-process&quot;</span></span><br><span class="line">            android:exported=<span class="string">&quot;false&quot;</span></span><br><span class="line">            android:multiprocess=<span class="string">&quot;true&quot;</span> /&gt;</span><br><span class="line">    &lt;/application&gt;</span><br><span class="line"></span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure><p>ProcessLifecycleOwnerInitializer只干一件事，注册ActivityLifecycleCallbacks，具体是使用一个无UI的ReportFragment, 利用Fragment的生命周期回调将Lifecycle Event发布出去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessLifecycleOwnerInitializer</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LifecycleDispatcher.init(getContext());</span><br><span class="line">        ProcessLifecycleOwner.init(getContext());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProcessLifecycleOwner提供了整个应用进程的生命周期，Lifecycle.Event.ON_CREATE事件只会发布一次，而Lifecycle.Event.ON_DESTROY则不会发布。Lifecycle.Event.ON_PAUSE和Lifecycle.Event.ON_STOP事件则会在上一个Activity走完对应生命周期方法后延时发布。这个延时时间足够长，确保当configuration change导致Activity销毁，重建时不会重新发布对应事件。</p><p>当我们需要监听应用从后台回到前台或者从前台到后台时，这个类就变得很有用。<br>我们可以在自定义Application中添加观察者，监听到ON_START事件表示应用回到前台，监听ON_STOP事件表示应用回到了后台。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicApp</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = BasicApp.class.getSimpleName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line"></span><br><span class="line">        ProcessLifecycleOwner.get().getLifecycle().addObserver(<span class="keyword">new</span> GenericLifecycleObserver() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(LifecycleOwner source, Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;ProcessLifecycleOwner onStateChanged, event: &quot;</span> + event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://github.com/taoliuh/taoliuh.github.io/blob/master/assets/img/ProcessLifecycleOwnerSeq.jpg?raw=true"></p><p>根据上图我们再来梳理一下ProcessLifecycleOwner发布消息的流程。<br>1.程序启动时，ProcessLifecycleOwner完成初始化，注册ActivityLifecycleCallbacks, 对ReportFragment设置监听器处理Fragment对应的onStart(), onResume()回调。</p><p>2.用户启动Activity, ReportFragment通过回调通知ProcessLifecycleOwner发送Lifecycle.Event.ON_START事件，并将计数器mStartedCounter加1，mStopSent置为false. 接下来收到onResume()回调，将计数器mResumedCounter加1，发送Lifecycle.Event.ON_RESUME事件，mPauseSent置为false.</p><p>3.用户启动一个新的Activity, ProcessLifecycleOwner注册的ActivityLifecycleCallbacks收到onActivityPaused回调，将计数器mResumedCounter减1，并将Lifecycle.Event.ON_PAUSE事件延时处理。如果在这段事件内configuration change导致Activity销毁并重建的话，那么计数器mResumedCounter, mStartedCounter值将发生改变，Lifecycle.Event.ON_PAUSE, Lifecycle.Event.ON_STOP事件将不会发布。当应用最后一个Activity销毁的时候，就会发布Lifecycle.Event.ON_STOP事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activityResumed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mResumedCounter++;</span><br><span class="line">    <span class="keyword">if</span> (mResumedCounter == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPauseSent) &#123;</span><br><span class="line">            mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);</span><br><span class="line">            mPauseSent = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mHandler.removeCallbacks(mDelayedPauseRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchPauseIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mResumedCounter == <span class="number">0</span>) &#123;</span><br><span class="line">        mPauseSent = <span class="keyword">true</span>;</span><br><span class="line">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchStopIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mStartedCounter == <span class="number">0</span> &amp;&amp; mPauseSent) &#123;</span><br><span class="line">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP);</span><br><span class="line">        mStopSent = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FragmentActivity继承自ComponentActivity，ComponentActivity会初始化LifecycleRegistry对象并在onCreate方法里会创建一个ReportFragment. 而LifecycleDispatcher里注册的ActivityLifecycleCallbacks也会在onActivityCreated方法中初始化ReportFragment, 将这个无UI的Fragment添加到FragmentActivity中，监听activity生命周期的变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">LifecycleOwner</span>, <span class="title">KeyEventDispatcher</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LifecycleRegistry mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;RestrictedApi&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        ReportFragment.injectIfNeededIn(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lifecycle内部定义了State和Event两个枚举类型，代表了组件所处的生命周期状态和即将变换状态的事件。下图清晰说明了状态的变化过程。<br><img data-src="https://developer.android.com/images/topic/libraries/architecture/lifecycle-states.png"></p><p>LifecycleRegistry初始化时的状态是INITIALIZED, FragmentActivity或者Fragment在生命周期方法执行时会调用handleLifecycleEvent方法完成目标状态的转换。在这个过程中，通过调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mLifecycleObserver.onStateChanged(owner, event)</span><br></pre></td></tr></table></figure><p>会将新的状态发布给订阅者。</p><p>值得注意的是，State状态是递增变化的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    <span class="keyword">final</span> ProductListViewModel viewModel =</span><br><span class="line">            ViewModelProviders.of(<span class="keyword">this</span>).get(ProductListViewModel.class);</span><br><span class="line">    subscribeUi(viewModel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribeUi</span><span class="params">(ProductListViewModel viewModel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Update the list when the data changes</span></span><br><span class="line">    viewModel.getProducts().observe(<span class="keyword">this</span>, <span class="keyword">new</span> Observer&lt;List&lt;ProductEntity&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(<span class="meta">@Nullable</span> List&lt;ProductEntity&gt; myProducts)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (myProducts != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mBinding.setIsLoading(<span class="keyword">false</span>);</span><br><span class="line">                mProductAdapter.setProductList(myProducts);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mBinding.setIsLoading(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// espresso does not know how to wait for data binding&#x27;s loop so we execute changes</span></span><br><span class="line">            <span class="comment">// sync.</span></span><br><span class="line">            mBinding.executePendingBindings();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，在onResume方法中添加LifecycleBoundObserver，调用LifecycleRegistry.addObserver方法，initialState为INITIALIZED, 根据当前的状态计算出targetState为STARTED, 然后在while循环中将INITALIZED至STARTED中的所有状态依次发送出去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line">    State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line">    ObserverWithState statefulObserver = <span class="keyword">new</span> ObserverWithState(observer, initialState);</span><br><span class="line">    ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleOwner == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// it is null we should be destroyed. Fallback quickly</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isReentrance = mAddingObserverCounter != <span class="number">0</span> || mHandlingEvent;</span><br><span class="line">    State targetState = calculateTargetState(observer);</span><br><span class="line">    mAddingObserverCounter++;</span><br><span class="line">    <span class="keyword">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class="line">        pushParentState(statefulObserver.mState);</span><br><span class="line">        <span class="comment">// upEvent获取下个状态并发布</span></span><br><span class="line">        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class="line">        popParentState();</span><br><span class="line">        <span class="comment">// mState / subling may have been changed recalculate</span></span><br><span class="line">        targetState = calculateTargetState(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isReentrance) &#123;</span><br><span class="line">        <span class="comment">// we do sync only on the top level.</span></span><br><span class="line">        sync();</span><br><span class="line">    &#125;</span><br><span class="line">    mAddingObserverCounter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://github.com/taoliuh/taoliuh.github.io/blob/master/assets/img/LiveData.jpg?raw=true"></p><p><img data-src="https://github.com/taoliuh/taoliuh.github.io/blob/master/assets/img/LiveDataSeq.jpg?raw=true"></p><p>ObserverWrapper通过mActive标记和mLastVersion变量跟踪状态和数据的变化，对于LifecycleBoundObserver来说只有当State是STARTED才能将数据发送出去，如果State为DESTROYED状态的时候则会移除Observer. 当LiveData的version大于OberverWrapper的version时，会将最新的数据发送出去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverWrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; mObserver;</span><br><span class="line">    <span class="keyword">boolean</span> mActive; </span><br><span class="line">    <span class="keyword">int</span> mLastVersion = START_VERSION;</span><br><span class="line"></span><br><span class="line">    ObserverWrapper(Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">        mObserver = observer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">detachObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">activeStateChanged</span><span class="params">(<span class="keyword">boolean</span> newActive)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (newActive == mActive) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// immediately set active state, so we&#x27;d never dispatch anything to inactive</span></span><br><span class="line">        <span class="comment">// owner</span></span><br><span class="line">        mActive = newActive;</span><br><span class="line">        <span class="keyword">boolean</span> wasInactive = LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span>;</span><br><span class="line">        LiveData.<span class="keyword">this</span>.mActiveCount += mActive ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class="line">            onActive();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span> &amp;&amp; !mActive) &#123;</span><br><span class="line">            onInactive();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mActive) &#123;</span><br><span class="line">            dispatchingValue(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在分析Android Architecture Component这个框架之前，先想想这个框架能为我们做什么，我们为什么要按照这套框架模式去构建app？它和MVP架构有什么区别？&lt;/p&gt;
&lt;p&gt;MVP, Clean, AAC架构的特点：&lt;br&gt;MVP架构的特点是面向接口编程。在View, Presenter, Model之间分别用接口做衔接，当有新的底层实现时，能够无缝替换。&lt;/p&gt;
&lt;p&gt;此外，MVP的View和Model并不产生依赖，因此可以说是对View和Model做了解耦。&lt;/p&gt;
&lt;p&gt;但MVP架构有其局限性。MVP需要创建太多的类和接口,并且每次通信都需要繁琐的通过接口传递信息&lt;/p&gt;
&lt;p&gt;google sample提供了一个todo-mvp sample, 里面有MVP+RxJava实现，Clean架构实现。这两种架构方式我都实践过，MVP+RxJava所有业务,UI逻辑都包含在Presenter里面, Presenter直接干预了UI在拿到数据后做什么，使得逻辑上没有发生解耦，正常来说，解耦意味着Presenter的只能边界仅限返回结果数据，由UI来根据数据处理UI逻辑。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>SparseArray源码分析</title>
    <link href="http://sonaive.me/2016/05/04/sparse-array-analysis/"/>
    <id>http://sonaive.me/2016/05/04/sparse-array-analysis/</id>
    <published>2016-05-04T01:33:07.000Z</published>
    <updated>2017-04-17T09:23:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>SparseArray</code>映射&lt;Integer, Object&gt;键值对。区别于对象数组，索引可以是非连续的。与使用<code>HashMap</code>映射Integer类型的key相比，使用<code>SpaseArray</code>存储效率更高，一方面它避免了自动对int型键自动装箱，另一方面它的数据结构不依赖额外的<code>Map.Entry</code>对象。</p></blockquote><blockquote><p>注意到这个容器使用数组保持映射关系，使用二分搜索寻找键。这种实现不适合存储大量数据项。与传统的HashMap比起来要慢，因为使用二分搜索查找，增加和移除操作需要在数组中插入和删除元素。存储上百条数据，性能差距不明显，不到50%.</p></blockquote><a id="more"></a><blockquote><p>为了提高性能，容器增加了移除key的优化：它不是立即压缩紧凑数组，而是将移除的entry标记为已删除。对于相同key, 这条数据可以被重用，或者在一次gc()操作的过程中紧凑所有移除的数据。当数组增长时或集合容量增加，或者获取数据值的时候，gc()操作就会在适当的时候执行。</p></blockquote><blockquote><p>使用<em>keyAt(int)</em>, *valueAt(int)<em>可以遍历容器中的数据。以升序索引值使用</em>keyAt(int)*遍历key将返回升序的key, 使用升序key遍历将相应返回升序value.</p></blockquote><p>SparseArray, 即稀疏数组，与HashMap不同的是，没有实现Map接口，不属于集合框架。定义了类似于集合中常用接口，比如<em>get(int)</em>, <em>put(int, Object)</em>, <em>remove(int)</em>, <em>size()</em>, <em>clear()</em>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object DELETED = <span class="keyword">new</span> Object();<span class="comment">// 移除标记</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mGarbage = <span class="keyword">false</span>;<span class="comment">// 执行gc()操作标记，当从数组中删除元素后置为true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] mKeys;<span class="comment">// key数组</span></span><br><span class="line"><span class="keyword">private</span> Object[] mValues;<span class="comment">// value数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mSize;<span class="comment">// 数组大小</span></span><br></pre></td></tr></table></figure><p>构造函数创建了初始大小为initialCapacity的key, value数组。但是capacity的计算，SparseArray与SparseArrayCompat调用了不同的实现.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> size, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> midVal = array[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (midVal &lt; value) &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; value) &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;  <span class="comment">// value found</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ~lo;  <span class="comment">// value not present</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上SparseArray的所有操作都是基于二分搜索，二分搜索的前提是数组是有序的，如果value在数组中存在，返回索引位置，否则最后计算出的lo值表示插入位置（0 &lt;= low &lt;= size），如果查找不到，取反返回负数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the mapping from the specified key, if there was any.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i =  ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mValues[i] != DELETED) &#123;</span><br><span class="line">            mValues[i] = DELETED;</span><br><span class="line">            mGarbage = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果key存在的话，移除指定key的映射关系，将对应的value标记为DELETED, mGarbage标记设置为true, 等待下一次操作触发gc()操作。</p><p>什么是gc操作？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Log.e(&quot;SparseArray&quot;, &quot;gc start with &quot; + mSize);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = mSize;</span><br><span class="line">    <span class="keyword">int</span> o = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] keys = mKeys;</span><br><span class="line">    Object[] values = mValues;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Object val = values[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val != DELETED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != o) &#123;</span><br><span class="line">                keys[o] = keys[i];</span><br><span class="line">                values[o] = val;</span><br><span class="line">                values[i] = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            o++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mGarbage = <span class="keyword">false</span>;</span><br><span class="line">    mSize = o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Log.e(&quot;SparseArray&quot;, &quot;gc end with &quot; + mSize);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里所谓的gc就是对数组进行整理压缩，使用两路指针i和o，将未标记为DELETED的映射都向数组的左端移动，很像垃圾收集器的标记-整理算法。</p><p>那么哪些操作会触发调用gc()呢？</p><ul><li>public void put(int key, E value)</li><li>public int size()</li><li>public int keyAt(int index)</li><li>public E valueAt(int index)</li><li>public void setValueAt(int index, E value)</li><li>public int indexOfKey(int key)</li><li>public int indexOfKey(int key)</li><li>public int indexOfValue(E value)</li><li>public void append(int key, E value)</li></ul><p>所有的访问操作在mGarbage为true的时候都会调用gc操作，此外put, append操作在数组需要扩容的时候也会调用gc操作。</p><p>直接看SparseArrayCompat的put和append实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a mapping from the specified key to the specified value,</span></span><br><span class="line"><span class="comment"> * replacing the previous mapping from the specified key if there</span></span><br><span class="line"><span class="comment"> * was one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, E value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i =  ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">    <span class="comment">// key存在，更新value</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mValues[i] = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 取反计算插入位置</span></span><br><span class="line">        i = ~i;</span><br><span class="line">        <span class="comment">// 插入位置非尾部且原来映射已经不存在了，则更新key-value</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;</span><br><span class="line">            mKeys[i] = key;</span><br><span class="line">            mValues[i] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试gc一下扩容，重新计算索引</span></span><br><span class="line">        <span class="keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;</span><br><span class="line">            gc();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Search again because indices may have changed.</span></span><br><span class="line">            i = ~ ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩容，每次扩容都是以2的幂次大小扩容，重新映射</span></span><br><span class="line">        <span class="keyword">if</span> (mSize &gt;= mKeys.length) &#123;</span><br><span class="line">            <span class="keyword">int</span> n =  ContainerHelpers.idealIntArraySize(mSize + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] nkeys = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            Object[] nvalues = <span class="keyword">new</span> Object[n];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Log.e(&quot;SparseArray&quot;, &quot;grow &quot; + mKeys.length + &quot; to &quot; + n);</span></span><br><span class="line">            System.arraycopy(mKeys, <span class="number">0</span>, nkeys, <span class="number">0</span>, mKeys.length);</span><br><span class="line">            System.arraycopy(mValues, <span class="number">0</span>, nvalues, <span class="number">0</span>, mValues.length);</span><br><span class="line"></span><br><span class="line">            mKeys = nkeys;</span><br><span class="line">            mValues = nvalues;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果插入的位置不是尾部，需要向右移动插入位置后面的所有映射</span></span><br><span class="line">        <span class="keyword">if</span> (mSize - i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Log.e(&quot;SparseArray&quot;, &quot;move &quot; + (mSize - i));</span></span><br><span class="line">            System.arraycopy(mKeys, i, mKeys, i + <span class="number">1</span>, mSize - i);</span><br><span class="line">            System.arraycopy(mValues, i, mValues, i + <span class="number">1</span>, mSize - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加映射关系</span></span><br><span class="line">        mKeys[i] = key;</span><br><span class="line">        mValues[i] = value;</span><br><span class="line">        mSize++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到插入映射的key保持了升序，因为每次put操作都会在已有的升序数组中计算插入的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Puts a key/value pair into the array, optimizing for the case where</span></span><br><span class="line"><span class="comment"> * the key is greater than all existing keys in the array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">int</span> key, E value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不是在尾部增加映射</span></span><br><span class="line">    <span class="keyword">if</span> (mSize != <span class="number">0</span> &amp;&amp; key &lt;= mKeys[mSize - <span class="number">1</span>]) &#123;</span><br><span class="line">        put(key, value);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;</span><br><span class="line">        gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pos = mSize;</span><br><span class="line">    <span class="keyword">if</span> (pos &gt;= mKeys.length) &#123;</span><br><span class="line">        <span class="keyword">int</span> n =  ContainerHelpers.idealIntArraySize(pos + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nkeys = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Object[] nvalues = <span class="keyword">new</span> Object[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Log.e(&quot;SparseArray&quot;, &quot;grow &quot; + mKeys.length + &quot; to &quot; + n);</span></span><br><span class="line">        System.arraycopy(mKeys, <span class="number">0</span>, nkeys, <span class="number">0</span>, mKeys.length);</span><br><span class="line">        System.arraycopy(mValues, <span class="number">0</span>, nvalues, <span class="number">0</span>, mValues.length);</span><br><span class="line"></span><br><span class="line">        mKeys = nkeys;</span><br><span class="line">        mValues = nvalues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mKeys[pos] = key;</span><br><span class="line">    mValues[pos] = value;</span><br><span class="line">    mSize = pos + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>append操作没什么特别的，只是针对要插入映射key大于数组中已存在的最大key的情况做了优化，减少了gc操作后重新计算索引的操作。</p><h4 id="为什么在数据量小的时候SparseArray的综合性能相对于HashMap要好？"><a href="#为什么在数据量小的时候SparseArray的综合性能相对于HashMap要好？" class="headerlink" title="为什么在数据量小的时候SparseArray的综合性能相对于HashMap要好？"></a>为什么在数据量小的时候SparseArray的综合性能相对于HashMap要好？</h4><p>SparseArray的主要优势是占用内存小，查询的时间复杂度是O(logn), n为数组的长度, 而HashMap的时间复杂度为O(n), n为发生hash冲突的元素个数。比起来HashMap查询性能更优。HashMap内部数据结构是一个Map.Entry数组，Map.Entry是一个单链表数据结构，维护了键值对，指向下一个元素的引用和key的hash值。每个映射均增加了内存开销。当数据量大的时候，SparseArray gc整理内存，put插入映射都是O(n)的时间复杂度，put操作还会造成数据迁移，而HashMap的时间复杂度为O(1).</p><h4 id="如何计算capacity？"><a href="#如何计算capacity？" class="headerlink" title="如何计算capacity？"></a>如何计算capacity？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">idealByteArraySize</span><span class="params">(<span class="keyword">int</span> need)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (need &lt;= (<span class="number">1</span> &lt;&lt; i) - <span class="number">12</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; i) - <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">return</span> need;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在扩容时计算新的容量大小使用的是上述方法，这个函数是为了方便内存分配，原则是给一个数组分配的内存空间最好是2的n次方大小，至于为什么要减去12, 是因为普通对象需要额外8字节空间管理对象相关信息(对象头部)，数组另加4字节记录数组长度。</p><h4 id="关于SparseArray-LongSparseArray"><a href="#关于SparseArray-LongSparseArray" class="headerlink" title="关于SparseArray, LongSparseArray."></a>关于SparseArray, LongSparseArray.</h4><p>两者实现原理相同，避免了整型，长整型键的自动装箱。</p><p>参考资料：<br><a href="http://bbs.csdn.net/topics/360092303">取反与补码</a><br><a href="https://stackoverflow.com/questions/32730919/what-is-the-rationale-behind-the-growing-policy-of-the-sparsearraycompat-in-andr">SparseArray growing policy</a><br><a href="http://www.cnblogs.com/zhanjindong/p/3757767.html">java对象的大小</a><br><a href="https://android.googlesource.com/platform/libcore/+/jb-mr2-release/luni/src/main/java/libcore/util/EmptyArray.java">EmptyArray</a><br><a href="https://android.googlesource.com/platform/frameworks/base.git/+/android-6.0.1_r31/core/java/com/android/internal/util/ArrayUtils.java">ArrayUtils</a><br><a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/com/android/internal/util/GrowingArrayUtils.java">GrowingArrayUtils</a><br><a href="http://blog.csdn.net/litefish/article/details/44078857">idealByteArraySize</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;SparseArray&lt;/code&gt;映射&amp;lt;Integer, Object&amp;gt;键值对。区别于对象数组，索引可以是非连续的。与使用&lt;code&gt;HashMap&lt;/code&gt;映射Integer类型的key相比，使用&lt;code&gt;SpaseArray&lt;/code&gt;存储效率更高，一方面它避免了自动对int型键自动装箱，另一方面它的数据结构不依赖额外的&lt;code&gt;Map.Entry&lt;/code&gt;对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;注意到这个容器使用数组保持映射关系，使用二分搜索寻找键。这种实现不适合存储大量数据项。与传统的HashMap比起来要慢，因为使用二分搜索查找，增加和移除操作需要在数组中插入和删除元素。存储上百条数据，性能差距不明显，不到50%.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>DiskLruCache源码分析</title>
    <link href="http://sonaive.me/2016/05/04/disk-lru-cache-analysis/"/>
    <id>http://sonaive.me/2016/05/04/disk-lru-cache-analysis/</id>
    <published>2016-05-04T01:08:59.000Z</published>
    <updated>2016-05-04T01:27:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个在文件系统上使用确定数量空间的缓存，每个cache entry包含一个字符串key和一个固定数字值。每个key必须匹配正则表达式<code>[a-z0-9_-]&#123;1,64&#125;</code>. 值表示为字节序列，可以通过流或者文件访问。每个值的长度在<em>0</em>和<em>Integer.MAX_VALUE</em>之间。</p><p>缓存将数据存储在文件系统的一个文件夹中。缓存对这个文件夹必须是独占的，缓存可以删除或者覆盖文件夹中的文件。多个进程在同一时间使用同一个缓存会导致错误。</p></blockquote><a id="more"></a><blockquote><p>缓存限制了存储到文件系统的字节数量。当存储的字节数超出了上限，缓存会在后台删除一些entries直到符合上限。这个上限并不严格：在等待文件被删除的过程中，缓存可以暂时超限。这个上限并不包含文件系统开销或者缓存日志，所以对存储空间敏感的应用应该设置一个保守的上限。</p><p>这个类会对一些I/O错误容错。如果文件丢失，对应的entries会从缓存中丢掉。当在缓存中写入值的时候发生了错误，edit操作会没有任何提示失败。调用者需要处理其他问题，捕获IOException并正确处理。</p></blockquote><p>既然是LRU Cache，那么怎么少得了<code>LinkedHashMap</code>这个数据结构呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;String, Entry&gt; lruEntries =</span><br><span class="line"><span class="keyword">new</span> LinkedHashMap&lt;String, Entry&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p><code>LinkedHashMap</code>设置accessOrder为true, 遍历的下一个元素就是Least Recently Used Element. 注意到Map里存放的<code>Entry</code>, 那么什么是<code>Entry</code>呢?</p><h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Lengths of this entry&#x27;s files. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span>[] lengths;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** True if this entry has ever been published. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> readable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The ongoing edit or null if this entry is not being edited. */</span></span><br><span class="line"><span class="keyword">private</span> Editor currentEditor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The sequence number of the most recently committed edit to this entry. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> sequenceNumber;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Entry</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.lengths = <span class="keyword">new</span> <span class="keyword">long</span>[valueCount];</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getCleanFile</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> File(directory, key + <span class="string">&quot;.&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getDirtyFile</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> File(directory, key + <span class="string">&quot;.&quot;</span> + i + <span class="string">&quot;.tmp&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entry对象一个key可以对应多个本地磁盘文件，采用<em>key + “.” + i</em>的形式保存要存储的文件，乍一想我好像并没有这样奇葩的需求啊，同一个文件我为什么要分开存储？找不到使用场景还真难以理解作者的设计意图。</p><p>OkHttp对磁盘缓存的用法彻底揭开了我的疑惑，对每一个response分两个文件存储，以.0和.1的结尾的文件名区分，分别存储响应的头部和实体部分，方便读取和处理(<a href="http://souly.cn/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/2015/09/08/okhttp%E7%BC%93%E5%AD%98%E6%B5%85%E6%9E%90/">点击查看OkHttp缓存处理</a>). <em>getCleanFile</em>和<em>getDirtyFile</em>表示以索引数字结尾的文件，也就是最后缓存写入的成员变量文件。</p><p>所以lengths成员变量表示一个key对应的多个文件的长度，readable成员变量表示文件是否可读，在完成一次成功的编辑（编辑代表磁盘存储操作）这个变量会被置为true, currentEditor成员变量表示当前entry是否正在被编辑，sequenceNumber成员变量表示最近一次编辑的序号。</p><h2 id="DiskLruCache如何存储文件到磁盘"><a href="#DiskLruCache如何存储文件到磁盘" class="headerlink" title="DiskLruCache如何存储文件到磁盘"></a>DiskLruCache如何存储文件到磁盘</h2><p>可以看下Universal Image Loader是如何往磁盘中存储图片的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">save</span><span class="params">(String imageUri, InputStream imageStream, IoUtils.CopyListener listener)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">DiskLruCache.Editor editor = cache.edit(getKey(imageUri));</span><br><span class="line"><span class="keyword">if</span> (editor == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OutputStream os = <span class="keyword">new</span> BufferedOutputStream(editor.newOutputStream(<span class="number">0</span>), bufferSize);</span><br><span class="line"><span class="keyword">boolean</span> copied = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">copied = IoUtils.copyStream(imageStream, os, listener, bufferSize);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">IoUtils.closeSilently(os);</span><br><span class="line"><span class="keyword">if</span> (copied) &#123;</span><br><span class="line">editor.commit();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">editor.abort();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> copied;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先根据图片的uri生成一个合法的key, 调用edit方法获取一个<code>DiskLruCache.Editor</code>对象，通过editor获取一个输出流，读取输入流中的字节数据写入到输出流，最后调用commit方法完成日志相关的操作。可以看出，<code>Editor</code>负责的是准备和善后工作，工具类<code>IoUtils</code>真正将数据写入到了缓存。</p><h2 id="Editor"><a href="#Editor" class="headerlink" title="Editor"></a>Editor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Editor</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Entry entry;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span>[] written;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasErrors;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> committed;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a new unbuffered output stream to write the value at</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> index&#125;. If the underlying output stream encounters errors</span></span><br><span class="line"><span class="comment"> * when writing to the filesystem, this edit will be aborted when</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #commit&#125; is called. The returned output stream does not throw</span></span><br><span class="line"><span class="comment"> * IOExceptions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OutputStream <span class="title">newOutputStream</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (DiskLruCache.<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (entry.currentEditor != <span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!entry.readable) &#123;</span><br><span class="line">written[index] = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">File dirtyFile = entry.getDirtyFile(index);</span><br><span class="line">FileOutputStream outputStream;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">outputStream = <span class="keyword">new</span> FileOutputStream(dirtyFile);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// Attempt to recreate the cache directory.</span></span><br><span class="line">directory.mkdirs();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">outputStream = <span class="keyword">new</span> FileOutputStream(dirtyFile);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e2) &#123;</span><br><span class="line"><span class="comment">// We are unable to recover. Silently eat the writes.</span></span><br><span class="line"><span class="keyword">return</span> NULL_OUTPUT_STREAM;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> FaultHidingOutputStream(outputStream);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Editor负责编辑Entry对象的值，调用newOutputStream创建输出流时，将written成员变量置为true, 表示entry可写，在对输出流写入数据时发生错误时会将标记变量hasErrors置为true, 完成一次编辑操作将committed置为true.</p><p>创建输出流检查当前Editor是否正确，否则抛出异常，创建一个dirty文件，指定输出流写入的目标文件就是dirty文件，最后创建出一个隐藏错误的输出流，或者当创建输出流失败时返回一个do nothing的NULL_OUTPUT_STREAM.</p><h2 id="DiskLruCache如何读取缓存"><a href="#DiskLruCache如何读取缓存" class="headerlink" title="DiskLruCache如何读取缓存"></a>DiskLruCache如何读取缓存</h2><p>同样，先看Universal Image Loader是如何读缓存的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">get</span><span class="params">(String imageUri)</span> </span>&#123;</span><br><span class="line">DiskLruCache.Snapshot snapshot = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">snapshot = cache.get(getKey(imageUri));</span><br><span class="line"><span class="keyword">return</span> snapshot == <span class="keyword">null</span> ? <span class="keyword">null</span> : snapshot.getFile(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">L.e(e);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (snapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line">snapshot.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用DiskLruCache的get方法获取对应key的一个Snapshot（快照）对象，然后根据对应的index获取File对象。</p><h2 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** A snapshot of the values for an entry. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Snapshot</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceNumber;</span><br><span class="line"><span class="keyword">private</span> File[] files;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> InputStream[] ins;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span>[] lengths;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Snapshot就是一个entry的值的快照，包含成员变量key, sequenceNumber, 缓存文件files及文件长度，缓存文件的输入流。通过get方法可以获取到对应key的一个Snapshot.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a snapshot of the entry named &#123;<span class="doctag">@code</span> key&#125;, or null if it doesn&#x27;t</span></span><br><span class="line"><span class="comment"> * exist is not currently readable. If a value is returned, it is moved to</span></span><br><span class="line"><span class="comment"> * the head of the LRU queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Snapshot <span class="title">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">checkNotClosed();</span><br><span class="line">validateKey(key);</span><br><span class="line">Entry entry = lruEntries.get(key);</span><br><span class="line"><span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!entry.readable) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open all streams eagerly to guarantee that we see a single published</span></span><br><span class="line"><span class="comment">// snapshot. If we opened streams lazily then the streams could come</span></span><br><span class="line"><span class="comment">// from different edits.</span></span><br><span class="line">File[] files = <span class="keyword">new</span> File[valueCount];</span><br><span class="line">InputStream[] ins = <span class="keyword">new</span> InputStream[valueCount];</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">File file;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">file = entry.getCleanFile(i);</span><br><span class="line">files[i] = file;</span><br><span class="line">ins[i] = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// A file must have been deleted manually!</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (ins[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">Util.closeQuietly(ins[i]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Snapshot(key, entry.sequenceNumber, files, ins, entry.lengths);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先做一般性检查（日志writer是否关闭，key是否合法），获取entry的clean文件，打开输入流，发布一个snapshot对象，调用getFile或者getInputStream可以获取到文件或者输入流对象。</p><h2 id="DiskLruCache如何移除缓存"><a href="#DiskLruCache如何移除缓存" class="headerlink" title="DiskLruCache如何移除缓存"></a>DiskLruCache如何移除缓存</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Drops the entry for &#123;<span class="doctag">@code</span> key&#125; if it exists and can be removed. Entries</span></span><br><span class="line"><span class="comment"> * actively being edited cannot be removed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if an entry was removed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">checkNotClosed();</span><br><span class="line">validateKey(key);</span><br><span class="line">Entry entry = lruEntries.get(key);</span><br><span class="line"><span class="keyword">if</span> (entry == <span class="keyword">null</span> || entry.currentEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">File file = entry.getCleanFile(i);</span><br><span class="line"><span class="keyword">if</span> (file.exists() &amp;&amp; !file.delete()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;failed to delete &quot;</span> + file);</span><br><span class="line">&#125;</span><br><span class="line">size -= entry.lengths[i];</span><br><span class="line">fileCount--;</span><br><span class="line">entry.lengths[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">lruEntries.remove(key);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移除一条entry, 正在被编辑的entry不可移除，删除clean文件，更新缓存大小size和文件数目fileCount.</p><p>围绕着Cache对象，其实就三个操作edit（将文件存到磁盘），get（从磁盘读取缓存文件），remove（从磁盘移除缓存）。但是还不够，如何避免缓存错误？如何在程序重新启动时恢复缓存数据（包括LRU顺序）？</p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>DiskLruCache引入了日志journal解决了上述问题。</p><blockquote><p> 使用一个名字为”journal”的日志文件。日志文件看起来像这样<br>libcore.io.DiskLruCache<br>1<br>100<br>2</p><p>CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054<br>DIRTY 335c4c6028171cfddfbaae1a9c313c52<br>CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342<br>REMOVE 335c4c6028171cfddfbaae1a9c313c52<br>DIRTY 1ab96a171faeeee38496d8b330771a7a<br>CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234<br>READ 335c4c6028171cfddfbaae1a9c313c52<br>READ 3400330d1dfc7f3f7f4b8d4d803dfcf6</p><p>前五行组成了日志文件头，分别是字符串常量”libcore.io.DiskLruCache”, cache版本，应用程序版本，value数目和一个空行。</p><p>接下来的行是记录了缓存entry的状态。每行包含用空格分隔的值：状态，key, 可选的指定状态值。<br>        o DIRTY 记录一条entry正被创建或更新。每一个成功的DIRTY操作应该跟随着CLEAN或REMOVE操作<br>          否则需要删除临时文件<br>        o CLEAN 记录一条entry被成功发布或者成功读取。CLEAN行跟随着每个值的长度大小。<br>        o READ 记录LRU访问顺序<br>        o REMOVE 记录被删除的entry</p><p>当发生cache操作的时候就会添加日志操作记录，时不时通过删除冗余行整理压缩日志。在压缩过程中会使用临时文件”journal.tmp”; 在打开cache的时候就会删除这个临时文件。</p></blockquote><p>前面的分析过程都略过了日志文件的操作，下面来分析通过操作日志是如何解决上述问题的。</p><p>edit操作，最后会向日志写入一条DIRTY操作记录</p><blockquote><p>journalWriter.append(DIRTY + ‘ ‘ + key + ‘\n’);</p></blockquote><p>get操作，最后会向日志写入一条READ操作记录</p><blockquote><p>journalWriter.append(READ + ‘ ‘ + key + ‘\n’);</p></blockquote><p>remove操作，最后会向日志写入一条REMOVE操作记录</p><blockquote><p>journalWriter.append(REMOVE + ‘ ‘ + key + ‘\n’);</p></blockquote><p>同时在edit操作结束后，接下来的commit操作会添加CLEAN或REMOVE操作记录</p><blockquote><p>journalWriter.append(CLEAN + ‘ ‘ + key + ‘\n’);</p></blockquote><p>如果磁盘缓存文件大小超过上限或者文件数目超过上限，或者日志冗余行超过上限就会把清理文件和重建日志的任务cleanupCallable提交到线程池中执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size &gt; maxSize || fileCount &gt; maxFileCount || journalRebuildRequired()) &#123;</span><br><span class="line">executorService.submit(cleanupCallable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Callable&lt;Void&gt; cleanupCallable = <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (DiskLruCache.<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (journalWriter == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// Closed.</span></span><br><span class="line">&#125;</span><br><span class="line">trimToSize();</span><br><span class="line">trimToFileCount();</span><br><span class="line"><span class="keyword">if</span> (journalRebuildRequired()) &#123;</span><br><span class="line">rebuildJournal();</span><br><span class="line">redundantOpCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上这些对日志的操作避免了缓存错误。<br>调用open创建DiskLruCache，会逐行读取日志信息，将状态为CLEAN/DIRTY/READ的记录恢复为entry，添加到LinkedHashMap集合中。调用processJournal删除混乱的entry，DIRTY记录行后面不是跟着CLEAN或者REMOVE记录行的属于混乱的记录。这样就在内存中恢复了上次访问状态的视图。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.rainstops.com/android/2015/03/06/DiskLruCache.html">DiskLruCahe的实现</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一个在文件系统上使用确定数量空间的缓存，每个cache entry包含一个字符串key和一个固定数字值。每个key必须匹配正则表达式&lt;code&gt;[a-z0-9_-]&amp;#123;1,64&amp;#125;&lt;/code&gt;. 值表示为字节序列，可以通过流或者文件访问。每个值的长度在&lt;em&gt;0&lt;/em&gt;和&lt;em&gt;Integer.MAX_VALUE&lt;/em&gt;之间。&lt;/p&gt;
&lt;p&gt;缓存将数据存储在文件系统的一个文件夹中。缓存对这个文件夹必须是独占的，缓存可以删除或者覆盖文件夹中的文件。多个进程在同一时间使用同一个缓存会导致错误。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Volley Q&amp;A</title>
    <link href="http://sonaive.me/2016/04/01/Volley%20Q&amp;A/"/>
    <id>http://sonaive.me/2016/04/01/Volley%20Q&amp;A/</id>
    <published>2016-04-01T09:49:30.000Z</published>
    <updated>2016-04-01T15:05:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Volley如何做内存优化的？"><a href="#1-Volley如何做内存优化的？" class="headerlink" title="1. Volley如何做内存优化的？"></a>1. Volley如何做内存优化的？</h1><p>有两个很有意思的类<code>ByteArrayPool</code>和<code>PoolingByteArrayOutputStream</code>, 当从网络取得响应数据流后，将响应数据转换为字节数组存储到<code>NetworkResponse</code>中。Volley适合数据量小，通信频繁的网络操作，如果按传统方式申请内存则分配内存，然后等待垃圾收集器回收，必然会造成频繁GC, 导致内存抖动，性能下降。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** com/android/volley/BasicNetwork.java */</span></span><br><span class="line"><span class="comment">/** Reads the contents of HttpEntity into a byte[]. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] entityToBytes(HttpEntity entity) <span class="keyword">throws</span> IOException, ServerError &#123;</span><br><span class="line">    PoolingByteArrayOutputStream bytes =</span><br><span class="line">            <span class="keyword">new</span> PoolingByteArrayOutputStream(mPool, (<span class="keyword">int</span>) entity.getContentLength());</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        InputStream in = entity.getContent();</span><br><span class="line">        <span class="keyword">if</span> (in == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServerError();</span><br><span class="line">        &#125;</span><br><span class="line">        buffer = mPool.getBuf(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">while</span> ((count = in.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bytes.write(buffer, <span class="number">0</span>, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes.toByteArray();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Close the InputStream and release the resources by &quot;consuming the content&quot;.</span></span><br><span class="line">            entity.consumeContent();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// This can happen if there was an exception above that left the entity in</span></span><br><span class="line">            <span class="comment">// an invalid state.</span></span><br><span class="line">            VolleyLog.v(<span class="string">&quot;Error occured when calling consumingContent&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mPool.returnBuf(buffer);</span><br><span class="line">        bytes.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种好的使用场景是，像I/O系统那样使用大块临时的字节数组缓存复制数据。在这种情况下，用户通常希望申请一块尽量小的缓冲区来保证性能，但并不关心缓冲区是否比要读取的数据长度大。上面的代码从池中申请了一块1024字节长度的缓冲区用于输入流中的数据写入到buf中，使用完毕将这部分空间返回给池。同样地，<code>PoolingByteArrayOutputStream</code>用于保存写入字节的缓存是随着写入字节增长而增长的，在调用expand方法的时候会将原来的缓存空间加入到池中。同时定义了缓冲池的最大空间，以空间换性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * com/android/volley/PoolingByteArrayOutputStream.java</span></span><br><span class="line"><span class="comment"> * Ensures there is enough space in the buffer for the given number of additional bytes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expand</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Can the buffer handle @i more bytes, if not expand it */</span></span><br><span class="line">    <span class="keyword">if</span> (count + i &lt;= buf.length) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span>[] newbuf = mPool.getBuf((count + i) * <span class="number">2</span>);</span><br><span class="line">    System.arraycopy(buf, <span class="number">0</span>, newbuf, <span class="number">0</span>, count);</span><br><span class="line">    mPool.returnBuf(buf);</span><br><span class="line">    buf = newbuf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Volley的缓存机制"><a href="#2-Volley的缓存机制" class="headerlink" title="2.Volley的缓存机制"></a>2.Volley的缓存机制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * com/android/volley/RequestQueue.java</span></span><br><span class="line"><span class="comment"> * Staging area for requests that already have a duplicate request in flight.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;containsKey(cacheKey) indicates that there is a request in flight for the given cache</span></span><br><span class="line"><span class="comment"> *          key.&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;get(cacheKey) returns waiting requests for the given cache key. The in flight request</span></span><br><span class="line"><span class="comment"> *          is &lt;em&gt;not&lt;/em&gt; contained in that list. Is null if no requests are staged.&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The set of all requests currently being processed by this RequestQueue. A Request</span></span><br><span class="line"><span class="comment"> * will be in this set if it is waiting in any queue or currently being processed by</span></span><br><span class="line"><span class="comment"> * any dispatcher.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = <span class="keyword">new</span> HashSet&lt;Request&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The cache triage queue. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue =</span><br><span class="line">    <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The queue of requests that are actually going out to the network. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue =</span><br><span class="line">    <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure><p>创建一个<code>RequestQueue</code>的时候会创建一个缓存请求队列，一个网络请求队列，一个等待任务集合和一个当前正在处理的请求的集合。创建5个工作线程，其中一个是<code>CacheDispather</code>, 处理缓存队列中任务，4个是<code>NetworkDispatcher</code>, 处理网络请求队列中的任务。如果一个请求任务需要缓存，就把它加入到缓存请求队列，如果等待任务集合中已经有这个请求，就把它加入到这个集合中相同的等待队列中。当一个任务完成时，检查等待队列中是否有相同的请求，把这些请求加入缓存队列中。这样做的目的是对于连续的相同的请求，提高缓存命中率。加入到缓存队列中的请求，在<code>CacheDispather</code>线程处理时如果没有命中缓存，就将这个任务加入到网络请求队列中去处理。如果命中了缓存，但是缓存过期，就将这个任务加入到网络请求队列中。如果Soft Expire过期，表示快到过期时间了，那么先返回缓存，然后更新缓存内容。</p><h2 id="3-如何判断缓存是否过期？"><a href="#3-如何判断缓存是否过期？" class="headerlink" title="3.如何判断缓存是否过期？"></a>3.如何判断缓存是否过期？</h2><h3 id="Cache-Control指令"><a href="#Cache-Control指令" class="headerlink" title="Cache-Control指令"></a>Cache-Control指令</h3><table><thead><tr><th>指令</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>no_cache</td><td>可省略</td><td>缓存前必须先确认有效性</td></tr><tr><td>no_store</td><td>无</td><td>不缓存请求或响应的内容</td></tr><tr><td>max_age</td><td>必需</td><td>响应的最大Age值</td></tr><tr><td>stale_while_revalidate</td><td>无</td><td>允许先返回缓存，再重新刷新</td></tr><tr><td>must_revalidate</td><td>无</td><td>可缓存但必须向源服务器进行确认</td></tr><tr><td>proxy_revalidate</td><td>无</td><td>要求中间缓存服务器对缓存的响应有效性再进行确认</td></tr></tbody></table><p>解析响应首部，通过指定首部字段Cache-Control, 就能操作缓存的工作机制，指令可选，通过多个”,”分隔，如果指令是no_cache或no_store, 那么不缓存；如果指令是max_age, 记录缓存最大age值，还有stale_while_revalidate, 允许先返回缓存，然后重新请求刷新，隐藏了延迟。此外must_revalidate, proxy_revalidate, 必须向源服务器进行确认。首部Expire获取过期时间，首部Last_Modified获取资源修改时间。优先使用Cache-Control来计算缓存的过期时间。如果一个请求命中了缓存，重新加入到请求队列中的请求就会加上原来请求的一些首部信息。If-None-Match用于指定字段值的实体标记ETag与请求资源的ETag不一致时，告诉服务器处理该请求。If-Modified-Since则会告诉服务器若该字段值早于资源的更新时间，就处理该请求，如果请求的资源没有更新过，返回304 Not Modified的响应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * com/android/volley/toolbox/HttpHeaderParser.java</span></span><br><span class="line"><span class="comment"> * Extracts a &#123;<span class="doctag">@link</span> Cache.Entry&#125; from a &#123;<span class="doctag">@link</span> NetworkResponse&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response The network response to parse headers from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a cache entry for the given response, or null if the response is not cacheable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Cache.<span class="function">Entry <span class="title">parseCacheHeaders</span><span class="params">(NetworkResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; headers = response.headers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> serverDate = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> lastModified = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> serverExpires = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> softExpire = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> finalExpire = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> maxAge = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> staleWhileRevalidate = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> hasCacheControl = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> mustRevalidate = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    String serverEtag = <span class="keyword">null</span>;</span><br><span class="line">    String headerValue;</span><br><span class="line"></span><br><span class="line">    headerValue = headers.get(<span class="string">&quot;Date&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (headerValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        serverDate = parseDateAsEpoch(headerValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    headerValue = headers.get(<span class="string">&quot;Cache-Control&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (headerValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        hasCacheControl = <span class="keyword">true</span>;</span><br><span class="line">        String[] tokens = headerValue.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.length; i++) &#123;</span><br><span class="line">            String token = tokens[i].trim();</span><br><span class="line">            <span class="keyword">if</span> (token.equals(<span class="string">&quot;no-cache&quot;</span>) || token.equals(<span class="string">&quot;no-store&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.startsWith(<span class="string">&quot;max-age=&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    maxAge = Long.parseLong(token.substring(<span class="number">8</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.startsWith(<span class="string">&quot;stale-while-revalidate=&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    staleWhileRevalidate = Long.parseLong(token.substring(<span class="number">23</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">&quot;must-revalidate&quot;</span>) || token.equals(<span class="string">&quot;proxy-revalidate&quot;</span>)) &#123;</span><br><span class="line">                mustRevalidate = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    headerValue = headers.get(<span class="string">&quot;Expires&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (headerValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        serverExpires = parseDateAsEpoch(headerValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    headerValue = headers.get(<span class="string">&quot;Last-Modified&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (headerValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        lastModified = parseDateAsEpoch(headerValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverEtag = headers.get(<span class="string">&quot;ETag&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache-Control takes precedence over an Expires header, even if both exist and Expires</span></span><br><span class="line">    <span class="comment">// is more restrictive.</span></span><br><span class="line">    <span class="keyword">if</span> (hasCacheControl) &#123;</span><br><span class="line">        softExpire = now + maxAge * <span class="number">1000</span>;</span><br><span class="line">        finalExpire = mustRevalidate</span><br><span class="line">                ? softExpire</span><br><span class="line">                : softExpire + staleWhileRevalidate * <span class="number">1000</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serverDate &gt; <span class="number">0</span> &amp;&amp; serverExpires &gt;= serverDate) &#123;</span><br><span class="line">        <span class="comment">// Default semantic for Expire header in HTTP specification is softExpire.</span></span><br><span class="line">        softExpire = now + (serverExpires - serverDate);</span><br><span class="line">        finalExpire = softExpire;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Cache.Entry entry = <span class="keyword">new</span> Cache.Entry();</span><br><span class="line">    entry.data = response.data;</span><br><span class="line">    entry.etag = serverEtag;</span><br><span class="line">    entry.softTtl = softExpire;</span><br><span class="line">    entry.ttl = finalExpire;</span><br><span class="line">    entry.serverDate = serverDate;</span><br><span class="line">    entry.lastModified = lastModified;</span><br><span class="line">    entry.responseHeaders = headers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断缓存是否需要更新，就是根据首部字段的信息判断的。相关方法是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** TTL for this record. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> ttl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Soft TTL for this record. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> softTtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Immutable response headers as received from server; must be non-null. */</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** True if the entry is expired. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.ttl &lt; System.currentTimeMillis();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** True if a refresh is needed from the original data source. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">refreshNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.softTtl &lt; System.currentTimeMillis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-请求失败如何进行重试？响应状态码非200如何处理"><a href="#4-请求失败如何进行重试？响应状态码非200如何处理" class="headerlink" title="4.请求失败如何进行重试？响应状态码非200如何处理"></a>4.请求失败如何进行重试？响应状态码非200如何处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> requestStart = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            responseHeaders = convertHeaders(httpResponse.getAllHeaders());</span><br><span class="line">            <span class="comment">// Handle cache validation.</span></span><br><span class="line">            <span class="keyword">if</span> (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</span><br><span class="line"></span><br><span class="line">                Entry entry = request.getCacheEntry();</span><br><span class="line">                <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, <span class="keyword">null</span>,</span><br><span class="line">                            responseHeaders, <span class="keyword">true</span>,</span><br><span class="line">                            SystemClock.elapsedRealtime() - requestStart);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// A HTTP 304 response does not have all header fields. We</span></span><br><span class="line">                <span class="comment">// have to use the header fields from the cache entry plus</span></span><br><span class="line">                <span class="comment">// the new ones from the response.</span></span><br><span class="line">                <span class="comment">// http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5</span></span><br><span class="line">                entry.responseHeaders.putAll(responseHeaders);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,</span><br><span class="line">                        entry.responseHeaders, <span class="keyword">true</span>,</span><br><span class="line">                        SystemClock.elapsedRealtime() - requestStart);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Handle moved resources</span></span><br><span class="line">            <span class="keyword">if</span> (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</span><br><span class="line">            String newUrl = responseHeaders.get(<span class="string">&quot;Location&quot;</span>);</span><br><span class="line">            request.setRedirectUrl(newUrl);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Some responses such as 204s do not have content.  We must check.</span></span><br><span class="line">            <span class="keyword">if</span> (httpResponse.getEntity() != <span class="keyword">null</span>) &#123;</span><br><span class="line">              responseContents = entityToBytes(httpResponse.getEntity());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// Add 0 byte response as a way of honestly representing a</span></span><br><span class="line">              <span class="comment">// no-content request.</span></span><br><span class="line">              responseContents = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (statusCode &lt; <span class="number">200</span> || statusCode &gt; <span class="number">299</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(statusCode, responseContents, responseHeaders, <span class="keyword">false</span>,</span><br><span class="line">                    SystemClock.elapsedRealtime() - requestStart);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line">            attemptRetryOnException(<span class="string">&quot;socket&quot;</span>, request, <span class="keyword">new</span> TimeoutError());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ConnectTimeoutException e) &#123;</span><br><span class="line">            attemptRetryOnException(<span class="string">&quot;connection&quot;</span>, request, <span class="keyword">new</span> TimeoutError());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Bad URL &quot;</span> + request.getUrl(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>响应超时、连接超时、I/O异常、认证错误、资源重定向都需要重试，注意到performRequet方法是一个无限循环，用完重试次数仍然失败则抛出VolleyError, 结束循环。注意到针对几种状态码进行了特别处理：<br>1）304 Not Modified 表示客户端发送附带条件的请求时，服务器端允许访问资源，但因发送请求未满足条件，直接返回304（服务器端资源未改变，可直接使用客户端未过期的缓存）。<br>2）301 Moved Permanently, 302 Not Found 永久重定向和临时重定向，表示请求的资源以及分配了新的URI, 通过首部字段Location获取新的资源地址。通过设定请求的跳转地址redirectUrl, 下次重试时直接使用新地址访问资源。<br>3）204 No Content 表示服务端接受的请求已经重新处理，但返回的响应报文中不含实体的主体部分。在这种情况下返回空内容，客户端不做处理。<br>4）小于200和大于299的状态码均抛出异常。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-Volley如何做内存优化的？&quot;&gt;&lt;a href=&quot;#1-Volley如何做内存优化的？&quot; class=&quot;headerlink&quot; title=&quot;1. Volley如何做内存优化的？&quot;&gt;&lt;/a&gt;1. Volley如何做内存优化的？&lt;/h1&gt;&lt;p&gt;有两个很有意思的类&lt;code&gt;ByteArrayPool&lt;/code&gt;和&lt;code&gt;PoolingByteArrayOutputStream&lt;/code&gt;, 当从网络取得响应数据流后，将响应数据转换为字节数组存储到&lt;code&gt;NetworkResponse&lt;/code&gt;中。Volley适合数据量小，通信频繁的网络操作，如果按传统方式申请内存则分配内存，然后等待垃圾收集器回收，必然会造成频繁GC, 导致内存抖动，性能下降。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>浅析Cube SDK里的ImageLoader组件是如何加载图片的（一）</title>
    <link href="http://sonaive.me/2016/03/30/image-loader-in-cube-sdk_1/"/>
    <id>http://sonaive.me/2016/03/30/image-loader-in-cube-sdk_1/</id>
    <published>2016-03-30T15:35:11.000Z</published>
    <updated>2016-04-01T09:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么使用轻量级的库？"><a href="#为什么使用轻量级的库？" class="headerlink" title="为什么使用轻量级的库？"></a>为什么使用轻量级的库？</h1><p>通常我会选择一些成熟的、功能丰富的框架，而这些框架通常是一些重量级的库，也许很多功能你根本用不到，而这些需求之外的功能直接导致了代码体积的增长。也许使用Proguard能移除没有使用的代码，但是类之间如果存在复杂的依赖耦合关系，Proguard还能起到多大作用，Who knows. 有人担心以后可能需要用到那些功能，现在的库没法满足需求. OK, 在使用这个库的时候了解是如何设计和实现的，优秀的库都是对扩展开放的，面向接口编程，那么需要新功能的话就扩展它吧，学习其他人造轮子也会提高自己的编程能力。</p><p>曾经一个朋友拿着他们公司大约200kb的类似小米游戏下载软件给我看，我简直无法相信，现在一个功能非常简单的apk动不动就是几兆，能做到这个程度，几乎让人怀疑这个软件的是否专业，然而它在低端机器上表现得都非常流畅。我们费劲心思琢磨如何给apk瘦身，结果增加几个大的jar包就打回了原形，我们要增加第三方统计，友盟的百度的都加上，再加上第三方登录，推送，这些sdk再引用了大量的库比如http组件，json解析，安装包一下子膨胀了几兆，难受但是无奈。</p><h1 id="一个图片加载框架的加载流程"><a href="#一个图片加载框架的加载流程" class="headerlink" title="一个图片加载框架的加载流程"></a>一个图片加载框架的加载流程</h1><pre><code>1. CubeImageView会检查图片是否已经加载过，图片已经加载完成并已经在显示的重复请求直接忽略。2. 检查图片是否在内存缓存中，如果再内存中，显示内存中的图片。否则，创建一个ImageTask, 传递给 ImageLoader, ImageTaskExecutor会处理这个任务。3. ImageTaskExecutor 会用后台线程处理这个ImageTask.4. ImageProvider负责获取图片，如果图片在本地有文件缓存，那么直接从本地文件加载；否则从网络下载，存文件缓存。5. 获取到图片之后，存内存缓存，通知加载完成。收到加载完成通知后，ImageView就可以显示图片了。</code></pre><p>根据这个加载流程，从核心类入手，逐个分析实现这样一个图片加载框架，我们关注的一些细节问题。</p><a id="more"></a><h1 id="核心类功能介绍"><a href="#核心类功能介绍" class="headerlink" title="核心类功能介绍"></a>核心类功能介绍</h1><h2 id="CubeImageView"><a href="#CubeImageView" class="headerlink" title="CubeImageView"></a>CubeImageView</h2><p><code>CubeImageView</code>有多个重载的<code>loadImage</code>方法，将加载的信息封装到<code>ImageRequest</code>, 客户端可以指定要加载图片最终显示的宽高。再看下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryLoadImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRequest == <span class="keyword">null</span> || TextUtils.isEmpty(mRequest.getUrl())) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> width = getWidth();</span><br><span class="line">    <span class="keyword">int</span> height = getHeight();</span><br><span class="line"></span><br><span class="line">    ViewGroup.LayoutParams lyp = getLayoutParams();</span><br><span class="line">    <span class="keyword">boolean</span> isFullyWrapContent = lyp != <span class="keyword">null</span> &amp;&amp; lyp.height == LayoutParams.WRAP_CONTENT &amp;&amp; lyp.width == LayoutParams.WRAP_CONTENT;</span><br><span class="line">    <span class="comment">// if the view&#x27;s bounds aren&#x27;t known yet, and this is not a wrap-content/wrap-content</span></span><br><span class="line">    <span class="comment">// view, hold off on loading the image.</span></span><br><span class="line">    <span class="keyword">if</span> (width == <span class="number">0</span> &amp;&amp; height == <span class="number">0</span> &amp;&amp; !isFullyWrapContent) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mRequest.setLayoutSize(width, height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. Check the previous ImageTask related to this ImageView</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != mImageTask) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// duplicated ImageTask, return directly.</span></span><br><span class="line">        <span class="keyword">if</span> (mImageTask.isLoadingThisUrl(mRequest)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ImageView is reused, detach it from the related ImageViews of the previous ImageTask.</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            mImageLoader.detachImageViewFromImageTask(mImageTask, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Let the ImageView hold this ImageTask. When ImageView is reused next time, check it in step 1.</span></span><br><span class="line">    ImageTask imageTask = mImageLoader.createImageTask(mRequest);</span><br><span class="line">    <span class="comment">//.createImageTask(mUrl, width, height, mImageReuseInfo);</span></span><br><span class="line">    mImageTask = imageTask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. Query cache, if hit, return at once.</span></span><br><span class="line">    <span class="keyword">boolean</span> hitCache = mImageLoader.queryCache(imageTask, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (hitCache) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mImageLoader.addImageTask(mImageTask, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码注释非常清晰，那么有几个问题。</p><h3 id="如何判断ImageView是被复用的，如何判断重复请求？"><a href="#如何判断ImageView是被复用的，如何判断重复请求？" class="headerlink" title="如何判断ImageView是被复用的，如何判断重复请求？"></a>如何判断ImageView是被复用的，如何判断重复请求？</h3><p>每个<code>CubeImageView</code>都绑定了一个<code>ImageTask</code>，<code>ImageTask</code>对请求进行了封装，内部类<code>ImageViewHolder</code>使用弱引用持有ImageView. 类似android消息处理中的一个类<code>Message</code>, 内部实现了一个池，但是正式发布的代码没有启用，作者说是因为不太稳定就没用。如果不使用对象池的话，更简单的做法是使用ImageView的setTag方法绑定请求或者加载地址，来达到防止重复加载或者图片错位的目的。<br><code>ImageTask</code>这个成员变量如果为null, 表示是第一次加载图片，并且创建<code>ImageTask</code>,查询内存缓存，内存缓存未击中，ze 否则的话这个ImageView就是复用的，接着根据url判断重复请求，如果是新的请求，移除原来的绑定。并将真正的加载任务<code>LoadImageTask</code>从任务队列中移除，取消正在执行的且不是预加载的图片请求。</p><h2 id="SimpleTask"><a href="#SimpleTask" class="headerlink" title="SimpleTask"></a>SimpleTask</h2><p><code>SimpleTask</code>继承Runnable, 是一个抽象类，定义了任务的4种状态，<code>STATE_NEW</code>, <code>STATE_RUNNING</code>, <code>STATE_FINISH</code>, <code>STATE_CANCELLED</code>, 代表任务不同的执行状态，使用主线程Looper创建静态Handler与主线程通信，通知任务完成或者取消。如果任务执行过程中出错，设置<code>ImageTask</code>的标记位mFlag, 在回调过程中检查加载是否成功，调用<code>DefaultImageLoadHandler</code>进行view更新，显示loading图片，下载失败的图片或者正确加载的图片。<code>SimpleTask</code>有一个mCurrentThread成员，保存当前正在执行的线程，可以在需要的时候方便调用中断退出任务。</p><h2 id="LoadImageTask"><a href="#LoadImageTask" class="headerlink" title="LoadImageTask"></a>LoadImageTask</h2><p><code>LoadImageTask</code>继承<code>SimpleTask</code>, 实现doInBackground方法，从Disk缓存或者网络取数据。重写onFinish, onCancel方法，onFinish是在主线程中执行的，调用<code>ImageLoadHandler</code>对图片进行处理和显示，删除任务队列中已经完成或者取消的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    SimpleTask work = (SimpleTask) msg.obj;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> MSG_TASK_DONE:</span><br><span class="line">            <span class="keyword">boolean</span> isCanceled = work.isCancelled();</span><br><span class="line">            work.mState.set(STATE_FINISH);</span><br><span class="line">            work.onFinish(isCanceled);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1）为什么要使用ConcurrentHashMap保存待执行的任务？"><a href="#1）为什么要使用ConcurrentHashMap保存待执行的任务？" class="headerlink" title="1）为什么要使用ConcurrentHashMap保存待执行的任务？"></a>1）为什么要使用ConcurrentHashMap保存待执行的任务？</h3><p>配置线程池<code>DefaultImageTaskExecutor</code>管理线程，线程池与工作队列BlockingQueue密切相关，其中在工作队列中保存了所有等待执行的任务。所有提交的任务都放入了这个队列，Executor从队列中取出任务执行，用户往队列中添加任务，形成了一个生产者-消费者模型。既然在创建ThreadPoolExecutor时就已经传入了一个BlockingQueue, 为何还需要使用ConcurrentHashMap保存所有的任务呢？原因是ImageLoader启用了生命周期管理，随着Activity或者Fragment生命周期的变迁，在UI从部分可见变为可见时调用pauseWork暂停工作，UI变为可见时调用resumeWork恢复工作，UI变为完全不可见时调用stopWork，将标记位mExitTaskEarly设置为true, 标记位mPauseWork设置为true, 正在执行的任务进入阻塞状态或者退出，已经执行完毕的任务可能在未更新界面的情况下退出，但是这些任务并没有从map里移除，UI从完全不可见变为可见时调用recoverWork, 重新提交map里剩余未执行完的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doInBackground</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        CLog.d(LOG_TAG, MSG_TASK_DO_IN_BACKGROUND, <span class="keyword">this</span>, mImageTask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mImageTask.getStatistics() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mImageTask.getStatistics().s1_beginLoad();</span><br><span class="line">    &#125;</span><br><span class="line">    Bitmap bitmap = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// Wait here if work is paused and the task is not cancelled</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mImageLoader.mPauseWorkLock) &#123;</span><br><span class="line">        <span class="keyword">while</span> (mImageLoader.mPauseWork &amp;&amp; !isCancelled()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    CLog.d(LOG_TAG, MSG_TASK_WAITING, <span class="keyword">this</span>, mImageTask);</span><br><span class="line">                &#125;</span><br><span class="line">                mImageLoader.mPauseWorkLock.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this task has not been cancelled by another</span></span><br><span class="line">    <span class="comment">// thread and the ImageView that was originally bound to this task is still bound back</span></span><br><span class="line">    <span class="comment">// to this task and our &quot;exit early&quot; flag is not set then try and fetch the bitmap from</span></span><br><span class="line">    <span class="comment">// the cache</span></span><br><span class="line">    <span class="keyword">if</span> (!isCancelled() &amp;&amp; !mImageLoader.mExitTasksEarly &amp;&amp; (mImageTask.isPreLoad() || mImageTask.stillHasRelatedImageView())) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bitmap = mImageLoader.mImageProvider.fetchBitmapData(mImageLoader, mImageTask, mImageLoader.mImageReSizer);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                CLog.d(LOG_TAG, MSG_TASK_AFTER_fetchBitmapData, <span class="keyword">this</span>, mImageTask, isCancelled());</span><br><span class="line">            &#125;</span><br><span class="line">            mDrawable = mImageLoader.mImageProvider.createBitmapDrawable(mImageLoader.mResources, bitmap);</span><br><span class="line">            mImageLoader.mImageProvider.addBitmapToMemCache(mImageTask.getIdentityKey(), mDrawable);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFinish</span><span class="params">(<span class="keyword">boolean</span> canceled)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        CLog.d(LOG_TAG, MSG_TASK_FINISH, <span class="keyword">this</span>, mImageTask, mImageLoader.mExitTasksEarly);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mImageLoader.mExitTasksEarly) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isCancelled() &amp;&amp; !mImageLoader.mExitTasksEarly) &#123;</span><br><span class="line">        mImageTask.onLoadTaskFinish(mDrawable, mImageLoader.mImageLoadHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mImageLoader.mLoadWorkList.remove(mImageTask.getIdentityKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2）如何退出正在执行的任务，暂停任务和恢复任务？"><a href="#2）如何退出正在执行的任务，暂停任务和恢复任务？" class="headerlink" title="2）如何退出正在执行的任务，暂停任务和恢复任务？"></a>2）如何退出正在执行的任务，暂停任务和恢复任务？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (mImageLoader.mPauseWorkLock) &#123;</span><br><span class="line">    <span class="keyword">while</span> (mImageLoader.mPauseWork &amp;&amp; !isCancelled()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                CLog.d(LOG_TAG, MSG_TASK_WAITING, <span class="keyword">this</span>, mImageTask);</span><br><span class="line">            &#125;</span><br><span class="line">            mImageLoader.mPauseWorkLock.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用wait使任务挂起。当条件改变时，调用notifyAll，唤醒所有在mPauseWorkLock上等待的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setPause</span><span class="params">(<span class="keyword">boolean</span> pause)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mPauseWorkLock) &#123;</span><br><span class="line">        mPauseWork = pause;</span><br><span class="line">        <span class="keyword">if</span> (!pause) &#123;</span><br><span class="line">            mPauseWorkLock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）如何配置线程池？"><a href="#3）如何配置线程池？" class="headerlink" title="3）如何配置线程池？"></a>3）如何配置线程池？</h3><p>使用一个线程工厂ThreadFactory来创建我们自定义名称的线程，根据cpu的核心数指定ThreadPoolExecutor的corePoolSize和maximumPoolSize，使用一个无界双向队列LinkedBlockingDeque存放任务，设置任务的优先级（FIFO或者LIFO），当队列中没有任务时，设置Timeout退出core线程，防止空闲的线程继续占用系统资源。如何在移动端配置线程池，如何在性能和内存折中，需要去实践对比一下不同的方案。比如Google官方的ThreadSample，对任务进行更细粒度的划分，将图片下载和decode分为两个不同的任务，分别放在下载任务线程池和decode任务线程池中并行执行，这样是能获得性能提升还是会导致性能下降？比如Volley使用一个数组保存启动的工作线程，线程的数目是固定的。</p><h2 id="图片复用"><a href="#图片复用" class="headerlink" title="图片复用"></a>图片复用</h2><p>比如用户头像，120*120图像下载到本地后，如有80*80的需求，无需再次下载，直接复用120*120图片。那么是如何实现的呢？<br>假如我需要加载一个地址为<a href="http://7xsj0t.com2.z0.glb.qiniucdn.com/IMG_20150613_161908.jpeg?imageView2/2/w/320">http://7xsj0t.com2.z0.glb.qiniucdn.com/IMG_20150613_161908.jpeg?imageView2/2/w/320</a>, 需要先定义一个identity字符串数组，比如[“2/w/120”, “2/w/320”, “2/w/640”], 模式2代表等比缩放， w/120表示宽最多120个像素<br>请求加载图片时指定图片复用信息，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mImageView.loadImage(mImageLoader, itemData, sImageReuseInfoManger.create(<span class="string">&quot;2/w/120&quot;</span>));</span><br></pre></td></tr></table></figure><p><code>ImageReuseInfoManger</code>创建了一个<code>ImageReuseInfo</code>, 保存可以替换的identity字符串数组。假如当前要加载的图片identity是”2/w/320”, 那么就可以复用disk缓存中identity为”2/w/640”的图片。</p><p>在加载完图片保存到缓存中的时候，会将该identity和url拼接成一个关键字作为缓存文件的名称。注意到这个url地址是原始地址去掉identity。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read from file cache</span></span><br><span class="line">inputStream = mDiskCacheProvider.getInputStream(fileCacheKey);</span><br><span class="line"></span><br><span class="line"><span class="comment">// try to reuse</span></span><br><span class="line"><span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (reuseInfo != <span class="keyword">null</span> &amp;&amp; reuseInfo.getReuseSizeList() != <span class="keyword">null</span> &amp;&amp; reuseInfo.getReuseSizeList().length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, String.format(MSG_FETCH_TRY_REUSE, imageTask));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String[] sizeKeyList = reuseInfo.getReuseSizeList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sizeKeyList.length; i++) &#123;</span><br><span class="line">            String size = sizeKeyList[i];</span><br><span class="line">            <span class="keyword">final</span> String key = imageTask.generateFileCacheKeyForReuse(size);</span><br><span class="line">            inputStream = mDiskCacheProvider.getInputStream(key);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    Log.d(TAG, String.format(MSG_FETCH_REUSE_SUCCESS, imageTask, size));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    Log.d(TAG, String.format(MSG_FETCH_REUSE_FAIL, imageTask, size, key));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在取disk缓存时，会检查复用信息，比如想要加载地址是“…/2/w/120”的图片，尝试读取key为“…/2/w/320”的缓存图片，没有的话再尝试下一个key为“…/2/w/640”的图片，查询不到复用的缓存就只能从网络下载。大致就是这样</p><p><a href="http://dev.bizo.com/2014/06/cached-thread-pool-considered-harmlful.html">Executors.newCachedThreadPool有毒</a> - Executors.newCachedThreadPool() considered harmful<br><a href="http://developer.android.com/training/multiple-threads/create-threadpool.html">ThreadSample</a> - Google官方最佳实践系列之使用多线程<br><a href="http://cube-sdk.liaohuqiu.net/cn/imageloader/">ImageLoader文档</a> - Cube SDK官方文档<br><a href="http://developer.qiniu.com/code/v6/api/kodo-api/image/imageview2.html">七牛文档</a> - 图片基本处理</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;为什么使用轻量级的库？&quot;&gt;&lt;a href=&quot;#为什么使用轻量级的库？&quot; class=&quot;headerlink&quot; title=&quot;为什么使用轻量级的库？&quot;&gt;&lt;/a&gt;为什么使用轻量级的库？&lt;/h1&gt;&lt;p&gt;通常我会选择一些成熟的、功能丰富的框架，而这些框架通常是一些重量级的库，也许很多功能你根本用不到，而这些需求之外的功能直接导致了代码体积的增长。也许使用Proguard能移除没有使用的代码，但是类之间如果存在复杂的依赖耦合关系，Proguard还能起到多大作用，Who knows. 有人担心以后可能需要用到那些功能，现在的库没法满足需求. OK, 在使用这个库的时候了解是如何设计和实现的，优秀的库都是对扩展开放的，面向接口编程，那么需要新功能的话就扩展它吧，学习其他人造轮子也会提高自己的编程能力。&lt;/p&gt;
&lt;p&gt;曾经一个朋友拿着他们公司大约200kb的类似小米游戏下载软件给我看，我简直无法相信，现在一个功能非常简单的apk动不动就是几兆，能做到这个程度，几乎让人怀疑这个软件的是否专业，然而它在低端机器上表现得都非常流畅。我们费劲心思琢磨如何给apk瘦身，结果增加几个大的jar包就打回了原形，我们要增加第三方统计，友盟的百度的都加上，再加上第三方登录，推送，这些sdk再引用了大量的库比如http组件，json解析，安装包一下子膨胀了几兆，难受但是无奈。&lt;/p&gt;
&lt;h1 id=&quot;一个图片加载框架的加载流程&quot;&gt;&lt;a href=&quot;#一个图片加载框架的加载流程&quot; class=&quot;headerlink&quot; title=&quot;一个图片加载框架的加载流程&quot;&gt;&lt;/a&gt;一个图片加载框架的加载流程&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. CubeImageView会检查图片是否已经加载过，图片已经加载完成并已经在显示的重复请求直接忽略。
2. 检查图片是否在内存缓存中，如果再内存中，显示内存中的图片。否则，创建一个ImageTask, 传递给 ImageLoader, ImageTaskExecutor会处理这个任务。
3. ImageTaskExecutor 会用后台线程处理这个ImageTask.
4. ImageProvider负责获取图片，如果图片在本地有文件缓存，那么直接从本地文件加载；否则从网络下载，存文件缓存。
5. 获取到图片之后，存内存缓存，通知加载完成。收到加载完成通知后，ImageView就可以显示图片了。&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据这个加载流程，从核心类入手，逐个分析实现这样一个图片加载框架，我们关注的一些细节问题。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>如何构建一个REST客户端</title>
    <link href="http://sonaive.me/2014/11/07/how-to-build-rest-client/"/>
    <id>http://sonaive.me/2014/11/07/how-to-build-rest-client/</id>
    <published>2014-11-07T04:11:44.000Z</published>
    <updated>2016-04-01T09:18:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是REST"><a href="#什么是REST" class="headerlink" title="什么是REST?"></a>什么是REST?</h1><p>含状态传输（英文：Representational State Transfer，简称REST）是一种软件架构风格。需要注意的是，REST是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML以及HTML这些现有的广泛流行的协议和标准。</p><ul><li>资源是由URI来指定。</li><li>对资源的操作包括获取、创建、修改和删除资源，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。</li><li>通过操作资源的表现形式来操作资源。</li><li>资源的表现形式则是XML或者HTML，取决于读者是机器还是人，是消费web服务的客户软件还是web浏览器。当然也可以是任何其他的格式</li></ul><p>REST绝不是只和HTTP相联系.你可以使用任意一种传输协议，但HTTP在REST风格架构中无疑是使用最广泛的。如果我要连接的服务已经有一个适配手机端的web网站，为何我还要开发一个应用呢？换句话说，为什么我们不使用浏览器，一步到位？</p><h1 id="为什么使用REST"><a href="#为什么使用REST" class="headerlink" title="为什么使用REST?"></a>为什么使用REST?</h1><p>好吧，除非浏览器技术发展起来了。我要列举5大原因。</p><ul><li>第一个原因是android应用是集成在android platform中，可以使用intents, content provider等等，浏览器做不到这些。</li><li>正是android平台为android应用提供了一些新功能，你的应用可以为其他应用提供intents.</li><li>你的应用可以在后台运行。这意味着如果要从服务器更新数据，当从服务器取得数据后，应用可以通知用户，让他们知道有数据可用。</li><li>应用和网络的连接稳定性有限。当网络较差时，请求可能失败。而android应用可以在后台进行多次重试，让用户在使用浏览器多次按刷按钮的痛苦中解放出来。</li><li>应用可以将从网络中取得资源，比如JSON, 或者二进制，或者XML格式的内容解析并存储在数据库中。因此，当你想取得新数据时，你就可以选择获取比数据库中数据更新的或者更老旧的数据，而不是和数据库中缓存相同的数据。这样你就不用获得所有html，就不用花长时间去下载javascript.</li><li>最后，你的应用可以和android操作系统在使用上保持一致性。<a id="more"></a></li></ul><h1 id="新手应该避免的"><a href="#新手应该避免的" class="headerlink" title="新手应该避免的"></a>新手应该避免的</h1><p>你是一个Java程序员。翻看了一下Android SDK,你对自己说，“我知道什么是activity,这有什么难的？我将创建一个activity, 知道REST方法执行耗时，因为会连接服务器，所以我会开启一个线程来执行。你决定这个线程是Activity里的内部类，并将取得的数据存储在内存中。</p><p>当你把app跑起来了，它运行得很快，没有崩溃，那么这为什么正确的方法？你得理解Android操作系统是如何工作的，Android操作系统是设计运行在有限资源的设备上的，当系统要启动一个新应用，并且内存不够时，它将决定强制关闭一个已经存在的应用。那么它如何作出这个决定？答案是，你要帮助操作系统做出决定。如果你的应用没有前台运行的activity，不向用户展示，没有执行一些操作，那么就会安全关闭。</p><img data-src="/assets/img/incorrect_implement.png" class="" title="[The Incorrect Implementation of REST Methods]">  <p>上图有什么问题呢？比如有这样一个场景：<br>启动线程执行REST方法，这时来了一个电话，当前activity状态为paused,这时操作系统说，这个进程没有前台的activity,所以我要杀死它，让它强制关闭。你猜会发生什么，提交的POST, PUT, DELETE方法也许就在服务器上执行，但是你的app永远也不会了解到执行结果。你执行了GET方法，获取到所有的数据，解析，you’re happy.操作系统却关闭了它。浪费带宽。你的方法存在的另一个问题是将数据存放在内存中。等等，这样运行的会快。至于为什么这么做不好，是因为你得不停从服务器获取数据，因为用户重启了设备，或者某个时间点进程被强制关闭了，浪费了CPU,电池电量，网络带宽。这不是写android应用的好方式。至于某些人说，从内存取数据要快得多，我要说，使用Content Provider,你可以将数据缓存到内存中。所以这都不是理由。</p><h1 id="三种正确的设计模式"><a href="#三种正确的设计模式" class="headerlink" title="三种正确的设计模式"></a>三种正确的设计模式</h1><p>google工程师在2011年的IO大会讲了三种设计模式，会带来最好的用户体验及最高的性能。一种是基于Service API,一种是基于Content Provider API,第三种使用Sync Adapter，是第二种的变种。这里只讨论第一种：</p><img data-src="/assets/img/option-A-use-service-api.png" class="" title="[Option A: Use a Service API]"><h2 id="由底至上"><a href="#由底至上" class="headerlink" title="由底至上"></a>由底至上</h2><h3 id="REST-METHOD"><a href="#REST-METHOD" class="headerlink" title="REST METHOD"></a>REST METHOD</h3><p>什么是REST METHOD？很简单，REST METHOD是具备这种能力的实体，准备HTTP URL,在某些情况下准备HTTP body,和服务器进行HTTP传输，处理响应数据。</p><h3 id="Processor"><a href="#Processor" class="headerlink" title="Processor"></a>Processor</h3><p>Processor的角色是将服务器资源映射到本地数据库中。我们需要往数据库中插入一条记录，该记录至少有两个字段，status column和result column. status列指示资源的状态。因为当执行REST方法时每种资源都具有传输状态。当资源正在传输过程中，资源没有和服务器成功同步，所以需要跟踪资源的状态。两方面原因：用户界面可能想要显示资源的某种状态，在同步的过程中，用户可能会离开当前activity。而你可以提醒用户说：“我正在同步资源，请继续使用app,当任务完成时我会通知你”。当该界面状态消失时，说明资源已经同步完毕。</p><p>因此status会保存一些标志。“我正在执行POST METHOD”, “我正在执行UPDATING”, “DELETING”.于是在任何时候，你只需要检查数据库就可以知道资源的状态。result列保存最后一次REST方法执行后的HTTP响应数据。</p><p>Processor在REST METHOD执行的前后都执行一次。当和服务器交互完毕，更新状态标记。</p><p>顺便说一句，这些标记可以用作其他用途。当你需要重试之前失败的操作怎么办？而知道将要进行的操作是不是很棒？posting标记告诉你需要执行POST METHOD.查看传输状态标记，是否有一个HTTP传输正在POST,如果有将不会开始一个新的请求。否则的话我可以选择重试。</p><p>还要提一句，用于不要在主线程中执行数据库操作或者Content Provider操作，可能会带来ANR.</p><h3 id="Service-和-ServiceHelper"><a href="#Service-和-ServiceHelper" class="headerlink" title="Service 和 ServiceHelper"></a>Service 和 ServiceHelper</h3><p>Service的角色是在activity消失后仍能在后台执行耗时操作。activity来去自由，它仅仅是应用程序的用户界面。用户可以在他执行耗时操作时选择点击主页按钮，点击关闭按钮。而耗时的操作仍在执行，最好的方式是让数据库去存储资源和状态。当你回来的时候，不管发生了什么，你都可以了解到发生了什么。执行了吗？仍在执行中？</p><p>Service内部维护一个任务队列    ，所有的请求通过ServiceHelper加入或者从队列中移除。当Service取出一个任务开始执行时，将任务交给Processor执行，执行完毕后交由Processor执行回调进行数据处理。</p><p>最重要的，当所有的操作完成，关闭service.对其它应用友好，当Service工作完毕，关闭它。</p><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><p>总是记得activities有它们的生命周期，paused, resumed或者destroyed.它们是由用户控制的界面。在onResume方法中我们要在service中增加回调，告诉它我回来了。在onPause移除回调。否则应用迟早会崩溃。</p><p>总是要考虑到一下三种场景：</p><p>activity发出了请求，当activity在前台的时候，一切正常。如果activity发出请求后，activity 暂停，回来，恢复，这时回调执行，你仍然能够执行回调，一切正常。在这种情况下你需要存储请求id,这样就可以询问Service Helper该请求是否正在执行。当执行onResume时回答是“是的，正在执行”。我们只需等待回调执行。</p><p>第三种最复杂，activity paused, request 完成，然后activity resumed.在onResume方法中询问请求是否正在执行，这次的回答是no.那么现在你明白了为什么我选择将响应的结果数据缓存到数据库中了吧。</p><h3 id="Content-Provider"><a href="#Content-Provider" class="headerlink" title="Content Provider"></a>Content Provider</h3><p>Content Provider支持ContentObservers. 当数据库表中的记录变化时，ContentObservers很方便从Content Provider接收到通知.你可以监控到某一个记录，表中的所有记录或者数据库中得所有资源的状态。</p><p><a href="http://zh.wikipedia.org/wiki/REST">WIKI</a> - REST 介绍</p><p><a href="https://www.youtube.com/watch?v=xHXn3Kg2IQE&list=FLvNeeEPLThnohZqA6_pthkQ&index=1">YouTuBe</a> - Google IO 大会视频</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是REST&quot;&gt;&lt;a href=&quot;#什么是REST&quot; class=&quot;headerlink&quot; title=&quot;什么是REST?&quot;&gt;&lt;/a&gt;什么是REST?&lt;/h1&gt;&lt;p&gt;含状态传输（英文：Representational State Transfer，简称REST）是一种软件架构风格。需要注意的是，REST是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML以及HTML这些现有的广泛流行的协议和标准。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;资源是由URI来指定。&lt;/li&gt;
&lt;li&gt;对资源的操作包括获取、创建、修改和删除资源，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。&lt;/li&gt;
&lt;li&gt;通过操作资源的表现形式来操作资源。&lt;/li&gt;
&lt;li&gt;资源的表现形式则是XML或者HTML，取决于读者是机器还是人，是消费web服务的客户软件还是web浏览器。当然也可以是任何其他的格式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;REST绝不是只和HTTP相联系.你可以使用任意一种传输协议，但HTTP在REST风格架构中无疑是使用最广泛的。如果我要连接的服务已经有一个适配手机端的web网站，为何我还要开发一个应用呢？换句话说，为什么我们不使用浏览器，一步到位？&lt;/p&gt;
&lt;h1 id=&quot;为什么使用REST&quot;&gt;&lt;a href=&quot;#为什么使用REST&quot; class=&quot;headerlink&quot; title=&quot;为什么使用REST?&quot;&gt;&lt;/a&gt;为什么使用REST?&lt;/h1&gt;&lt;p&gt;好吧，除非浏览器技术发展起来了。我要列举5大原因。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个原因是android应用是集成在android platform中，可以使用intents, content provider等等，浏览器做不到这些。&lt;/li&gt;
&lt;li&gt;正是android平台为android应用提供了一些新功能，你的应用可以为其他应用提供intents.&lt;/li&gt;
&lt;li&gt;你的应用可以在后台运行。这意味着如果要从服务器更新数据，当从服务器取得数据后，应用可以通知用户，让他们知道有数据可用。&lt;/li&gt;
&lt;li&gt;应用和网络的连接稳定性有限。当网络较差时，请求可能失败。而android应用可以在后台进行多次重试，让用户在使用浏览器多次按刷按钮的痛苦中解放出来。&lt;/li&gt;
&lt;li&gt;应用可以将从网络中取得资源，比如JSON, 或者二进制，或者XML格式的内容解析并存储在数据库中。因此，当你想取得新数据时，你就可以选择获取比数据库中数据更新的或者更老旧的数据，而不是和数据库中缓存相同的数据。这样你就不用获得所有html，就不用花长时间去下载javascript.&lt;/li&gt;
&lt;li&gt;最后，你的应用可以和android操作系统在使用上保持一致性。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>如何防止内存泄漏</title>
    <link href="http://sonaive.me/2014/08/26/how-to-avoid-memeory-leak/"/>
    <id>http://sonaive.me/2014/08/26/how-to-avoid-memeory-leak/</id>
    <published>2014-08-26T02:53:10.000Z</published>
    <updated>2014-08-26T09:25:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>#Memory Leak</p><p>考虑下面的代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mLeakyHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许不是那么明显，这块代码能造成大量的内存溢出。Android Lint 会提示如下警告</p><blockquote><p>In Android, Handler classes should be static or leaks might occur.</p></blockquote><p>但是内存是在哪儿溢出的，是如何发生的？首先通过列出我们已经知道的事实来找问题的根源：</p><p>1.当Android应用程序第一次启动时，framework在应用程序的主线程里创建了一个Looper对象。Looper实现了一个简单的消息队列，依次处理队列里的消息对象。所有的应用程序框架里的事件（比如Activity的生命周期函数调用，按钮点击事件等等）都封装为消息对象，被加入到Looper的消息队列中并依次处理。主线程的Looper在整个应用的生命周期里会一直存在。</p><p>2.当在主线程里实例化一个Handler时，就和Looper的消息队列关联在一起了。发送到消息队列的消息会持有Handler的引用，使得当Looper最后处理消息时候，framework可以调用Handler#handleMessage（Message）.</p><p>3.在Java中，非静态匿名内部类会持有它所在外部类的隐式引用。而静态内部类不会。</p><a id="more"></a><p>那么到底内存是在什么地方泄漏的?非常巧妙，思考下面一段示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mLeakyHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Post a message and delay its execution for 10 minutes.</span></span><br><span class="line">        mLeakyHandler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">        &#125;, <span class="number">60</span> * <span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Go back to the previous Activity.</span></span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当activity结束掉，延迟的消息会在主线程的队列中生存10分钟，直到被处理。该消息持有activity <code>Handler</code>的引用，且<code>Handler</code>持有外部类的隐式引用（当前情况下是SampleActivity）.该引用会持续存在直到消息被处理，因此妨碍了<code>Activity Context</code>被垃圾回收，从而导致应用程序资源泄漏。注意在15行的匿名内部类会导致一样的情况。非静态匿名内部类的实例持有它们外部类的的隐式引用，因此<code>Context</code>会泄漏。</p><p>为了修复这个问题，创建一个类继承<code>Handler</code>或者使用静态内部类。静态内部类不会持有它的外部类的隐式引用，所以activity不会溢出。如果需要在<code>Handler</code>中调用外部activity的方法，使<code>Handler</code>持有activity的<code>WeakReference</code>,因此不会导致<code>Context</code>意外溢出。当实例化匿名的<code>Runnable</code>类时，为了修复内存溢出，为这个类创建一个静态域（因为匿名内部类的静态实例不会持有它的外部类的引用）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Instances of static inner classes do not hold an implicit</span></span><br><span class="line"><span class="comment">     * reference to their outer class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;SampleActivity&gt; mActivity;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(SampleActivity activity)</span> </span>&#123;</span><br><span class="line">            mActivity = <span class="keyword">new</span> WeakReference&lt;SampleActivity&gt;(activity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            SampleActivity activity = mActivity.get();</span><br><span class="line">            <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyHandler mHandler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Instances of anonymous classes do not hold an implicit</span></span><br><span class="line"><span class="comment">     * reference to their outer class when they are &quot;static&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable sRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Post a message and delay its execution for 10 minutes.</span></span><br><span class="line">        mHandler.postDelayed(sRunnable, <span class="number">60</span> * <span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Go back to the previous Activity.</span></span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态和非静态内部类之间的区别很微妙，但每个Android程序员都应该理解它。底线是什么？如果内部类的实例比activity的<br>生命周期长，避免在activity中使用非静态内部类。相反，推荐使用静态内部类，持有activity的弱引用。</p><p>以下是原文链接：<br><a href="http://www.androiddesignpatterns.com/2013/01/inner-class-handler-memory-leak.html">How to Leak a Context: Handlers &amp; Inner Classes</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;#Memory Leak&lt;/p&gt;
&lt;p&gt;考虑下面的代码块：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SampleActivity&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Activity&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Handler mLeakyHandler = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Handler() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handleMessage&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Message msg)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;也许不是那么明显，这块代码能造成大量的内存溢出。Android Lint 会提示如下警告&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In Android, Handler classes should be static or leaks might occur.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是内存是在哪儿溢出的，是如何发生的？首先通过列出我们已经知道的事实来找问题的根源：&lt;/p&gt;
&lt;p&gt;1.当Android应用程序第一次启动时，framework在应用程序的主线程里创建了一个Looper对象。Looper实现了一个简单的消息队列，依次处理队列里的消息对象。所有的应用程序框架里的事件（比如Activity的生命周期函数调用，按钮点击事件等等）都封装为消息对象，被加入到Looper的消息队列中并依次处理。主线程的Looper在整个应用的生命周期里会一直存在。&lt;/p&gt;
&lt;p&gt;2.当在主线程里实例化一个Handler时，就和Looper的消息队列关联在一起了。发送到消息队列的消息会持有Handler的引用，使得当Looper最后处理消息时候，framework可以调用Handler#handleMessage（Message）.&lt;/p&gt;
&lt;p&gt;3.在Java中，非静态匿名内部类会持有它所在外部类的隐式引用。而静态内部类不会。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Loader框架</title>
    <link href="http://sonaive.me/2014/08/25/the-loader-framework/"/>
    <id>http://sonaive.me/2014/08/25/the-loader-framework/</id>
    <published>2014-08-25T03:23:47.000Z</published>
    <updated>2016-04-01T09:16:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Loader-Framework"><a href="#Loader-Framework" class="headerlink" title="Loader Framework"></a>Loader Framework</h1><p> 如果在应用里通过ContentProvider取得数据，最糟的情况可能有一下几种：</p><ol><li>你完全不知道android应用该怎么写，在主线程里去执行耗时操作</li><li>使用AsyncTask:<br>你的app在屏幕方向改变的时候崩溃了，于是你google到stackoverflow上的答案并锁定了屏幕方向，接着你加上了容易出错的代码，在Activity中detach,attach AsyncTask.</li><li>使用CursorLoader<br>从android HoneyComb到Kitkat,Loader Framework中的Loader子类都只有孤零零的CusorLoader.很可能你会使用其他的异步操作，而不仅仅是通过ContentProvider.你也许想要访问SharedPreferences,读文件或者请求访问web API.那样的话，你需要Loader<SomeOtherDataThanCursor>,但正确实现它会有点复杂。<br>我将带你完整过一遍整个流程，理解Loaders是如何工作的，为你的Loaders实现一个正确的基类，实现一个修复所有问题的CursorLoader,并扩展使其具备通知多个Uri的能力。这将是一篇长博客，所以拿一杯你喜欢的饮料边看边喝吧。<a id="more"></a></li></ol><h2 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h2><p>Loader应该要做到三件事：</p><ol><li>在后台线程里加载数据</li><li>缓存已经加载的数据，这样就不会在屏幕方向变化的时候重新加载一遍了。</li><li>如果可行，监控数据源并在适当的时候重新加载最新的数据。</li></ol><p>Loader类自身并没有在后台线程里加载数据的机制，或者你自己实现，或者你继承AsyncTaskLoader.这部分内容就涵盖了我们需求列表第一点。</p><p>AsyncTaskLoader并没有处理好第二点。事实上AsyncTaskLoader远远没有到达功能完全，比如这种看上去非常合理的实现并不能起作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DasLoader</span> <span class="keyword">extends</span> <span class="title">AsyncTaskLoader</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DasLoader</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">loadInBackground</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Das&quot;</span>; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##AbstractLoader v1##</p><p>下面这种实现提供了所有的加载和缓存数据的模板代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLoader</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AsyncTaskLoader</span>&lt;<span class="title">T</span>&gt; </span>&#123; </span><br><span class="line">    T mResult; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractLoader</span><span class="params">(Context context)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">super</span>(context); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliverResult</span><span class="params">(T result)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (isReset()) &#123; </span><br><span class="line">            releaseResources(result); </span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        T oldResult = mResult; </span><br><span class="line">        mResult = result; </span><br><span class="line">        <span class="keyword">if</span> (isStarted()) &#123; </span><br><span class="line">            <span class="keyword">super</span>.deliverResult(result);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (oldResult != result &amp;&amp; oldResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">            releaseResources(oldResult); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCanceled</span><span class="params">(T result)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">super</span>.onCanceled(result); </span><br><span class="line">        releaseResources(result); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onReset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onReset(); <span class="comment">// Ensure the loader is stopped onStopLoading();</span></span><br><span class="line">        releaseResources(mResult);</span><br><span class="line">        mResult = <span class="keyword">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStartLoading</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (mResult != <span class="keyword">null</span>) &#123; </span><br><span class="line">            deliverResult(mResult); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (takeContentChanged() || mResult == <span class="keyword">null</span>) &#123; </span><br><span class="line">            forceLoad();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStopLoading</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        cancelLoad(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">releaseResources</span><span class="params">(T result)</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>奇怪的是framework没有提供这样的类。而现在你可以像这样写你的自定义Loader.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DasLoader</span> <span class="keyword">extends</span> <span class="title">AbstractLoader</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DasLoader</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">loadInBackground</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Das&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但为什么需要这些代码？理解Loaders的关键是理解loader行为的不同状态：started,stopped,abandoned和reset。当进入每种状态时，相应的callback就会执行。</p><p>onStartLoading:已经创建Loader,要么加载数据，或者返回已缓存的数据。</p><p>onStopLoading:Loader应该保存缓存的数据，监控数据源变化，但不能加载数据。比如用户回到屏幕桌面，就会发生这种情况。</p><p>onAbandoned:重新启动Loader.在onCreateLoader回调方法里创建了Loader的新实例，并在Fragment或者Activity里加载新数据。在被废弃的Loader里监控数据源或者重新加载数据没有意义–数据会在新Loader里加载。当新Loader发送数据后，这个被废弃的Loader会被重置。</p><p>onReset:Loader加载的之前的数据不会再使用，并会清空。该Loader可能会重新启动，所以在你的Loader实现里清空状态。</p><p>AsyncTaskLoader提供了额外的回调：</p><p>onCancelled:当加载时发现不会再使用该数据会调用，比如当AsyncTask执行onLoadInBackgroud时被取消。在该回调中你应该处理好释放资源。</p><p>因为onRest callback和deliverResults实现中都需要释放资源，我们的AbstractLoader提供了方便的realeaseResources()方法用来关闭Cursor或者文件处理器等等。</p><p>现在梳理一遍AbstractLoader的实现。当使用 LoaderManager.initLoader()启动了Loader，onStartLoading被调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">T mResult; </span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStartLoading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mResult != <span class="keyword">null</span>) &#123;             </span><br><span class="line">        deliverResult(mResult);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (takeContentChanged() || mResult == <span class="keyword">null</span>) &#123; </span><br><span class="line">        forceLoad();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在AbstractLoader中的mResult成员保存已加载的数据.如果已经加载完数据，只需要将结果传递到Loader 客户端中。如果缓存数据为空，或者Loader被通知有新数据可以获取，就会调用forceLoad()方法强制加载数据。该方法启动AsyncTask在后台线程中调用loadInBackground,最后结果会传给deliverResults方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliverResult</span><span class="params">(T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isReset()) &#123;</span><br><span class="line">        releaseResources(result);     </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    T oldResult = mResult; </span><br><span class="line">    mResult = result; </span><br><span class="line">    <span class="keyword">if</span> (isStarted()) &#123;</span><br><span class="line">        <span class="keyword">super</span>.deliverResult(result);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (oldResult != result &amp;&amp; oldResult != <span class="keyword">null</span>) &#123; </span><br><span class="line">        releaseResources(oldResult);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块有些有趣的事情。首先，检查loader是否进入reset状态。该状态中之前所有的资源都要是否，所以只需要处理新加载的数据。然后将数据交换到缓存中，调用deliverResults，释放之前缓存的资源。</p><p>当Fragment或者Activity中活动的Loader停止了，Loaders仍然要进入到stop状态。这意味着Loaders需要保持缓存数据，监控数据是否有效，但是不能加载数据或者将数据传递到UI线程中。按照AsyncTaskLoader，意味着取消所有运行的AsyncTasks.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStopLoading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cancelLoad();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前AsyncTaskLoader的实现并没有打断当前的任务，只保证了这些任务的结果不会传递到UI线程中。然而，这些任务执行的结果需要释放资源，所以onCancelled回调将执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCanceled</span><span class="params">(T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCanceled(result);</span><br><span class="line">    releaseResources(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后需要实现的都回调是onReset:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onReset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onReset(); <span class="comment">// Ensure the loader is stopped </span></span><br><span class="line">    onStopLoading();</span><br><span class="line">    releaseResources(mResult);</span><br><span class="line">    mResult = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这儿有两件重要的事。第一，Loader可以从started状态转换到reset状态，意味着它仍然可有活动的AsyncTasks执行loadInBackgroud.我们需要先将其停止。然后，根据约定，需要释放资源并清空缓存。</p><p>onAbandoned 回调呢？AbstractLoader 自己没有监控数据源，所以这个回调不必实现。</p><p>##CursorLoader##</p><p>那么我们如何能实现观测数据源并自动重新加载的Loader呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCursorLoader</span> <span class="keyword">extends</span> <span class="title">AbstractLoader</span>&lt;<span class="title">Cursor</span>&gt; </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ForceLoadContentObserver mObserver; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCursorLoader</span><span class="params">(Context context)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        mObserver = <span class="keyword">new</span> ForceLoadContentObserver();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// bunch of setters for uri, projection, selection, etc. Omitted for brevity </span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">loadInBackground</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Cursor cursor = getContext().getContentResolver().query(mUri, mProjection, mSelection, mSelectionArgs, mSortOrder); </span><br><span class="line">        <span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Ensure the cursor window is filled</span></span><br><span class="line">            cursor.getCount(); </span><br><span class="line">            cursor.registerContentObserver(mObserver); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该实现有两个bug,其中一个是功能性bug.让我们着手后一个吧。</p><p>onStartLoading 当进入到该状态时，监控数据源。但想一想，如果查询需要200ms,而数据每150ms发生变化，那将会怎样？Loader将永远不能将数据发送出去，因为每个load请求将会在loadInBackgroud执行的过程中被content observer取消。</p><p>我猜大概就是这个原因，CursorLoader的Android实现在数据加载完成时注册observer.采用这种方法，第一次加载的数据将会尽快发送出去，但接下来加载的数据只会在加载过程中数据源不发生变化时才能发送出去。</p><p>##Fixing CursorLoader##</p><ol><li>当第一次加载的数据发送完毕，注册ContentObserver.</li><li>在onAbandon方法里取消注册ContentObserver.</li></ol><p>第一点要求我们改变deliverResult方法，因此我们这样来修改AbstractLoader:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliverResult</span><span class="params">(T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isReset()) &#123;</span><br><span class="line">        releaseResources(result);</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    T oldResult = mResult; </span><br><span class="line">    mResult = result; </span><br><span class="line">    <span class="keyword">if</span> (isStarted()) &#123; </span><br><span class="line">        <span class="keyword">if</span> (oldResult != result) &#123;</span><br><span class="line">            onNewDataDelivered(result);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">super</span>.deliverResult(result); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (oldResult != result &amp;&amp; oldResult != <span class="keyword">null</span>) &#123; </span><br><span class="line">        releaseResources(oldResult); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onNewDataDelivered</span><span class="params">(T data)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>CursorLoader看起来应该像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCursorLoader</span> <span class="keyword">extends</span> <span class="title">AbstractLoader</span>&lt;<span class="title">Cursor</span>&gt; </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ForceLoadContentObserver mObserver; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCursorLoader</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        mObserver = <span class="keyword">new</span> ForceLoadContentObserver();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// bunch of setters for uri, projection, selection, etc. Omitted for brevity </span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">loadInBackground</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        Cursor cursor = getContext().getContentResolver().query(mUri, mProjection, mSelection, mSelectionArgs, mSortOrder); </span><br><span class="line">        <span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// Ensure the cursor window is filled</span></span><br><span class="line">            cursor.getCount(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> cursor; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onNewDataDelivered</span><span class="params">(Cursor data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onNewDataDelivered(data);</span><br><span class="line">        data.registerContentObserver(mObserver);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二部分–在onAbandon里取消注册observer会有点困难。如果observer没有注册，调用Cursor.unregisterContentObserver是非法的，而且当deliverResults没被调用的时候onAbandon可以被调用。于是，我们创建一个代理的ContentObserver。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisableableContentObserver</span> <span class="keyword">extends</span> <span class="title">ContentObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ContentObserver mWrappedObserver; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsEnabled = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DisableableContentObserver</span><span class="params">(ContentObserver wrappedObserver)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> Handler());</span><br><span class="line">        mWrappedObserver = wrappedObserver;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">boolean</span> selfChange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mIsEnabled) &#123; </span><br><span class="line">            mWrappedObserver.onChange(selfChange); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">boolean</span> isEnabled)</span> </span>&#123; </span><br><span class="line">        mIsEnabled = isEnabled; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCursorLoader</span> <span class="keyword">extends</span> <span class="title">AbstractLoader</span>&lt;<span class="title">Cursor</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DisableableContentObserver mObserver;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCursorLoader</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        mObserver = <span class="keyword">new</span> DisableableContentObserver(<span class="keyword">new</span> ForceLoadContentObserver());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bunch of setters for uri, projection, selection, etc. Omitted for brevity</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStartLoading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mObserver.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">super</span>.onStartLoading();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onAbandon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mObserver.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onReset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mObserver.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">super</span>.onReset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">loadInBackground</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Cursor cursor = getContext().getContentResolver().query(mUri, mProjection, mSelection,</span><br><span class="line">        mSelectionArgs, mSortOrder);</span><br><span class="line">        <span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Ensure the cursor window is filled</span></span><br><span class="line">            cursor.getCount();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onNewDataDelivered</span><span class="params">(Cursor data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onNewDataDelivered(data);</span><br><span class="line">        data.registerContentObserver(mObserver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##AbstractObservingLoader##<br>The CursorLoader is a bit special case, because the Cursor itself contains ContentObservable. In most cases however the content observers and loaded data would be completely separated. For these cases it would be useful to have a base class for Loader which registers some ContentObservers:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractObservingLoader</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractLoader</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> DisableableContentObserver mObserver;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsRegistered;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractObservingLoader</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        mObserver = <span class="keyword">new</span> DisableableContentObserver(<span class="keyword">new</span> ForceLoadContentObserver());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStartLoading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mObserver.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">super</span>.onStartLoading();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onAbandon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mObserver.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        unregisterObserver(mObserver);</span><br><span class="line">        mIsRegistered = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onReset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mObserver.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        unregisterObserver(mObserver);</span><br><span class="line">        mIsRegistered = <span class="keyword">false</span>;z</span><br><span class="line">        <span class="keyword">super</span>.onReset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onNewDataDelivered</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mIsRegistered) &#123;</span><br><span class="line">            mIsRegistered = <span class="keyword">true</span>;</span><br><span class="line">            registerObserver(mObserver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(ContentObserver observer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">unregisterObserver</span><span class="params">(ContentObserver observer)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We need to keep the registered state in our Loader, because the default Observable implementation doesn’t like registering the same observer twice or unregistering not registered observer.<br>Now we can use this class as a base for a Loader which should be reloaded when one of specified Uris is triggered:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCursorLoader</span> <span class="keyword">extends</span> <span class="title">AbstractObservingLoader</span>&lt;<span class="title">Cursor</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCursorLoader</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bunch of setters for uri, projection, selection, etc. Omitted for brevity</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">loadInBackground</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Cursor cursor = getContext().getContentResolver().query(mUri, mProjection, mSelection,</span><br><span class="line">        mSelectionArgs, mSortOrder);</span><br><span class="line">        <span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Ensure the cursor window is filled</span></span><br><span class="line">            cursor.getCount();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onNewDataDelivered</span><span class="params">(Cursor data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onNewDataDelivered(data);</span><br><span class="line">        data.registerContentObserver(mObserver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(ContentObserver observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Uri uri : mObservedUris) &#123;</span><br><span class="line">            getContext().getContentResolver().registerContentObserver(uri, <span class="keyword">true</span>, observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">unregisterObserver</span><span class="params">(ContentObserver observer)</span> </span>&#123;</span><br><span class="line">        getContext().getContentResolver().unregisterContentObserver(observer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是原文链接：<br><a href="http://chalup.github.io/blog/2014/06/12/android-loaders/">android loaders</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Loader-Framework&quot;&gt;&lt;a href=&quot;#Loader-Framework&quot; class=&quot;headerlink&quot; title=&quot;Loader Framework&quot;&gt;&lt;/a&gt;Loader Framework&lt;/h1&gt;&lt;p&gt; 如果在应用里通过ContentProvider取得数据，最糟的情况可能有一下几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;你完全不知道android应用该怎么写，在主线程里去执行耗时操作&lt;/li&gt;
&lt;li&gt;使用AsyncTask:&lt;br&gt;你的app在屏幕方向改变的时候崩溃了，于是你google到stackoverflow上的答案并锁定了屏幕方向，接着你加上了容易出错的代码，在Activity中detach,attach AsyncTask.&lt;/li&gt;
&lt;li&gt;使用CursorLoader&lt;br&gt;从android HoneyComb到Kitkat,Loader Framework中的Loader子类都只有孤零零的CusorLoader.很可能你会使用其他的异步操作，而不仅仅是通过ContentProvider.你也许想要访问SharedPreferences,读文件或者请求访问web API.那样的话，你需要Loader&lt;SomeOtherDataThanCursor&gt;,但正确实现它会有点复杂。&lt;br&gt;我将带你完整过一遍整个流程，理解Loaders是如何工作的，为你的Loaders实现一个正确的基类，实现一个修复所有问题的CursorLoader,并扩展使其具备通知多个Uri的能力。这将是一篇长博客，所以拿一杯你喜欢的饮料边看边喝吧。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>搭建我的 github + octopress 博客</title>
    <link href="http://sonaive.me/2014/07/28/build-blog-with-github-plus-octopress/"/>
    <id>http://sonaive.me/2014/07/28/build-blog-with-github-plus-octopress/</id>
    <published>2014-07-28T13:00:27.000Z</published>
    <updated>2014-08-26T02:14:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-Github-Octopress-搭建博客"><a href="#使用-Github-Octopress-搭建博客" class="headerlink" title="使用 Github+Octopress 搭建博客"></a>使用 Github+Octopress 搭建博客</h1><h2 id="1-对git不陌生"><a href="#1-对git不陌生" class="headerlink" title="1.对git不陌生"></a>1.对git不陌生</h2><h2 id="2-创建github页面。注意："><a href="#2-创建github页面。注意：" class="headerlink" title="2.创建github页面。注意："></a>2.创建github页面。注意：</h2><blockquote><p>Github Pages for users and organizations uses the master branch like the public directory on a web server, serving up the files at your Pages url <a href="http://username.github.io/">http://username.github.io</a>. As a result, you’ll want to work on the source for your blog in the source branch and commit the generated content to the master branch. Octopress has a configuration task that helps you set all this up.</p></blockquote><p>比如我的github用户名是taoliuh,那么创建一个github page 一定要设置仓库名称为taoliuh.github.io</p><h2 id="3-绑定独立域名"><a href="#3-绑定独立域名" class="headerlink" title="3.绑定独立域名"></a>3.绑定独立域名</h2><p>我在godaddy上注册的域名。在域名管理页面添加ANAME： @204.232.175.78 CNAME： http your-custom-domain</p><h2 id="4-发表博客"><a href="#4-发表博客" class="headerlink" title="4.发表博客"></a>4.发表博客</h2><pre><code>rake new_post[&quot;Hello World: The First of Many New Blog Posts&quot;]</code></pre><h2 id="5-预览"><a href="#5-预览" class="headerlink" title="5.预览"></a>5.预览</h2><pre><code>rake preview</code></pre><h2 id="6-发布"><a href="#6-发布" class="headerlink" title="6.发布"></a>6.发布</h2><p>当完成写作时，你需要生成并发布到github.</p><pre><code>rake generaterake deploy</code></pre><p>不要忘了提交改动的文件到source分支</p><pre><code>git add . git commit -am &#39;Add my first blog post&#39; git push origin source</code></pre><p>现在你就能在这个页面user-name.github.io看到你的博客文章了～LOL</p><a id="more"></a><p><a href="https://pages.github.com/">设置github page</a></p><p><a href="http://robdodson.me/blog/2012/04/30/custom-domain-with-octopress-and-github-pages/">Custom Domain With Octopress and Github Pages</a></p><p><a href="http://beyondvincent.com/blog/2013/07/27/107-hello-page-of-github/">你好！github页面</a></p><p><a href="http://yanping.me/cn/blog/2012/01/07/theming-and-customization/">为Octopress修改主题和自定义样式</a></p><p><a href="http://biaobiaoqi.me/blog/2013/07/10/decorate-octopress/">定制Octopress</a></p><p><a href="http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/">象写程序一样写博客：搭建基于github的博客</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;使用-Github-Octopress-搭建博客&quot;&gt;&lt;a href=&quot;#使用-Github-Octopress-搭建博客&quot; class=&quot;headerlink&quot; title=&quot;使用 Github+Octopress 搭建博客&quot;&gt;&lt;/a&gt;使用 Github+Octopress 搭建博客&lt;/h1&gt;&lt;h2 id=&quot;1-对git不陌生&quot;&gt;&lt;a href=&quot;#1-对git不陌生&quot; class=&quot;headerlink&quot; title=&quot;1.对git不陌生&quot;&gt;&lt;/a&gt;1.对git不陌生&lt;/h2&gt;&lt;h2 id=&quot;2-创建github页面。注意：&quot;&gt;&lt;a href=&quot;#2-创建github页面。注意：&quot; class=&quot;headerlink&quot; title=&quot;2.创建github页面。注意：&quot;&gt;&lt;/a&gt;2.创建github页面。注意：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Github Pages for users and organizations uses the master branch like the public directory on a web server, serving up the files at your Pages url &lt;a href=&quot;http://username.github.io/&quot;&gt;http://username.github.io&lt;/a&gt;. As a result, you’ll want to work on the source for your blog in the source branch and commit the generated content to the master branch. Octopress has a configuration task that helps you set all this up.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如我的github用户名是taoliuh,那么创建一个github page 一定要设置仓库名称为taoliuh.github.io&lt;/p&gt;
&lt;h2 id=&quot;3-绑定独立域名&quot;&gt;&lt;a href=&quot;#3-绑定独立域名&quot; class=&quot;headerlink&quot; title=&quot;3.绑定独立域名&quot;&gt;&lt;/a&gt;3.绑定独立域名&lt;/h2&gt;&lt;p&gt;我在godaddy上注册的域名。在域名管理页面添加ANAME： @204.232.175.78 CNAME： http your-custom-domain&lt;/p&gt;
&lt;h2 id=&quot;4-发表博客&quot;&gt;&lt;a href=&quot;#4-发表博客&quot; class=&quot;headerlink&quot; title=&quot;4.发表博客&quot;&gt;&lt;/a&gt;4.发表博客&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;rake new_post[&amp;quot;Hello World: The First of Many New Blog Posts&amp;quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;5-预览&quot;&gt;&lt;a href=&quot;#5-预览&quot; class=&quot;headerlink&quot; title=&quot;5.预览&quot;&gt;&lt;/a&gt;5.预览&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;rake preview&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;6-发布&quot;&gt;&lt;a href=&quot;#6-发布&quot; class=&quot;headerlink&quot; title=&quot;6.发布&quot;&gt;&lt;/a&gt;6.发布&lt;/h2&gt;&lt;p&gt;当完成写作时，你需要生成并发布到github.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rake generate
rake deploy&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不要忘了提交改动的文件到source分支&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add . 
git commit -am &amp;#39;Add my first blog post&amp;#39; 
git push origin source&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在你就能在这个页面user-name.github.io看到你的博客文章了～LOL&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
