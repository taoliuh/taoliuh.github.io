<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>So Naive</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sonaive.com/"/>
  <updated>2014-11-08T18:12:21.000Z</updated>
  <id>http://sonaive.com/</id>
  
  <author>
    <name>So Naive</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何构建一个REST客户端</title>
    <link href="http://sonaive.com/2014/11/07/how-to-build-rest-client/"/>
    <id>http://sonaive.com/2014/11/07/how-to-build-rest-client/</id>
    <published>2014-11-07T04:11:44.000Z</published>
    <updated>2014-11-08T18:12:21.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;什么是REST&quot;&gt;&lt;a href=&quot;#什么是REST&quot; class=&quot;headerlink&quot; title=&quot;什么是REST?&quot;&gt;&lt;/a&gt;什么是REST?&lt;/h1&gt;&lt;p&gt;含状态传输（英文：Representational State Transfer，简称REST）是一种软件架构风格。需要注意的是，REST是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML以及HTML这些现有的广泛流行的协议和标准。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;资源是由URI来指定。&lt;/li&gt;
&lt;li&gt;对资源的操作包括获取、创建、修改和删除资源，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。&lt;/li&gt;
&lt;li&gt;通过操作资源的表现形式来操作资源。&lt;/li&gt;
&lt;li&gt;资源的表现形式则是XML或者HTML，取决于读者是机器还是人，是消费web服务的客户软件还是web浏览器。当然也可以是任何其他的格式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;REST绝不是只和HTTP相联系.你可以使用任意一种传输协议，但HTTP在REST风格架构中无疑是使用最广泛的。如果我要连接的服务已经有一个适配手机端的web网站，为何我还要开发一个应用呢？换句话说，为什么我们不使用浏览器，一步到位？&lt;/p&gt;
&lt;h1 id=&quot;为什么使用REST&quot;&gt;&lt;a href=&quot;#为什么使用REST&quot; class=&quot;headerlink&quot; title=&quot;为什么使用REST?&quot;&gt;&lt;/a&gt;为什么使用REST?&lt;/h1&gt;&lt;p&gt;好吧，除非浏览器技术发展起来了。我要列举5大原因。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个原因是android应用是集成在android platform中，可以使用intents, content provider等等，浏览器做不到这些。&lt;/li&gt;
&lt;li&gt;正是android平台为android应用提供了一些新功能，你的应用可以为其他应用提供intents.&lt;/li&gt;
&lt;li&gt;你的应用可以在后台运行。这意味着如果要从服务器更新数据，当从服务器取得数据后，应用可以通知用户，让他们知道有数据可用。&lt;/li&gt;
&lt;li&gt;应用和网络的连接稳定性有限。当网络较差时，请求可能失败。而android应用可以在后台进行多次重试，让用户在使用浏览器多次按刷按钮的痛苦中解放出来。&lt;/li&gt;
&lt;li&gt;应用可以将从网络中取得资源，比如JSON, 或者二进制，或者XML格式的内容解析并存储在数据库中。因此，当你想取得新数据时，你就可以选择获取比数据库中数据更新的或者更老旧的数据，而不是和数据库中缓存相同的数据。这样你就不用获得所有html，就不用花长时间去下载javascript.&lt;/li&gt;
&lt;li&gt;最后，你的应用可以和android操作系统在使用上保持一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;新手应该避免的&quot;&gt;&lt;a href=&quot;#新手应该避免的&quot; class=&quot;headerlink&quot; title=&quot;新手应该避免的&quot;&gt;&lt;/a&gt;新手应该避免的&lt;/h1&gt;&lt;p&gt;你是一个Java程序员。翻看了一下Android SDK,你对自己说，“我知道什么是activity,这有什么难的？我将创建一个activity, 知道REST方法执行耗时，因为会连接服务器，所以我会开启一个线程来执行。你决定这个线程是Activity里的内部类，并将取得的数据存储在内存中。&lt;/p&gt;
&lt;p&gt;当你把app跑起来了，它运行得很快，没有崩溃，那么这为什么正确的方法？你得理解Android操作系统是如何工作的，Android操作系统是设计运行在有限资源的设备上的，当系统要启动一个新应用，并且内存不够时，它将决定强制关闭一个已经存在的应用。那么它如何作出这个决定？答案是，你要帮助操作系统做出决定。如果你的应用没有前台运行的activity，不向用户展示，没有执行一些操作，那么就会安全关闭。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;img src=&quot;/images/incorrect_implement.png&quot; title=&quot;[The Incorrect Implementation of REST Methods]&quot;&gt;  
&lt;p&gt;上图有什么问题呢？比如有这样一个场景：&lt;br&gt;启动线程执行REST方法，这时来了一个电话，当前activity状态为paused,这时操作系统说，这个进程没有前台的activity,所以我要杀死它，让它强制关闭。你猜会发生什么，提交的POST, PUT, DELETE方法也许就在服务器上执行，但是你的app永远也不会了解到执行结果。你执行了GET方法，获取到所有的数据，解析，you’re happy.操作系统却关闭了它。浪费带宽。你的方法存在的另一个问题是将数据存放在内存中。等等，这样运行的会快。至于为什么这么做不好，是因为你得不停从服务器获取数据，因为用户重启了设备，或者某个时间点进程被强制关闭了，浪费了CPU,电池电量，网络带宽。这不是写android应用的好方式。至于某些人说，从内存取数据要快得多，我要说，使用Content Provider,你可以将数据缓存到内存中。所以这都不是理由。&lt;/p&gt;
&lt;h1 id=&quot;三种正确的设计模式&quot;&gt;&lt;a href=&quot;#三种正确的设计模式&quot; class=&quot;headerlink&quot; title=&quot;三种正确的设计模式&quot;&gt;&lt;/a&gt;三种正确的设计模式&lt;/h1&gt;&lt;p&gt;google工程师在2011年的IO大会讲了三种设计模式，会带来最好的用户体验及最高的性能。一种是基于Service API,一种是基于Content Provider API,第三种使用Sync Adapter，是第二种的变种。这里只讨论第一种：&lt;/p&gt;
&lt;img src=&quot;/images/option-A-use-service-api.png&quot; title=&quot;[Option A: Use a Service API]&quot;&gt;
&lt;h2 id=&quot;由底至上&quot;&gt;&lt;a href=&quot;#由底至上&quot; class=&quot;headerlink&quot; title=&quot;由底至上&quot;&gt;&lt;/a&gt;由底至上&lt;/h2&gt;&lt;h3 id=&quot;REST-METHOD&quot;&gt;&lt;a href=&quot;#REST-METHOD&quot; class=&quot;headerlink&quot; title=&quot;REST METHOD&quot;&gt;&lt;/a&gt;REST METHOD&lt;/h3&gt;&lt;p&gt;什么是REST METHOD？很简单，REST METHOD是具备这种能力的实体，准备HTTP URL,在某些情况下准备HTTP body,和服务器进行HTTP传输，处理响应数据。&lt;/p&gt;
&lt;h3 id=&quot;Processor&quot;&gt;&lt;a href=&quot;#Processor&quot; class=&quot;headerlink&quot; title=&quot;Processor&quot;&gt;&lt;/a&gt;Processor&lt;/h3&gt;&lt;p&gt;Processor的角色是将服务器资源映射到本地数据库中。我们需要往数据库中插入一条记录，该记录至少有两个字段，status column和result column. status列指示资源的状态。因为当执行REST方法时每种资源都具有传输状态。当资源正在传输过程中，资源没有和服务器成功同步，所以需要跟踪资源的状态。两方面原因：用户界面可能想要显示资源的某种状态，在同步的过程中，用户可能会离开当前activity。而你可以提醒用户说：“我正在同步资源，请继续使用app,当任务完成时我会通知你”。当该界面状态消失时，说明资源已经同步完毕。&lt;/p&gt;
&lt;p&gt;因此status会保存一些标志。“我正在执行POST METHOD”, “我正在执行UPDATING”, “DELETING”.于是在任何时候，你只需要检查数据库就可以知道资源的状态。result列保存最后一次REST方法执行后的HTTP响应数据。&lt;/p&gt;
&lt;p&gt;Processor在REST METHOD执行的前后都执行一次。当和服务器交互完毕，更新状态标记。&lt;/p&gt;
&lt;p&gt;顺便说一句，这些标记可以用作其他用途。当你需要重试之前失败的操作怎么办？而知道将要进行的操作是不是很棒？posting标记告诉你需要执行POST METHOD.查看传输状态标记，是否有一个HTTP传输正在POST,如果有将不会开始一个新的请求。否则的话我可以选择重试。&lt;/p&gt;
&lt;p&gt;还要提一句，用于不要在主线程中执行数据库操作或者Content Provider操作，可能会带来ANR.&lt;/p&gt;
&lt;h3 id=&quot;Service-和-ServiceHelper&quot;&gt;&lt;a href=&quot;#Service-和-ServiceHelper&quot; class=&quot;headerlink&quot; title=&quot;Service 和 ServiceHelper&quot;&gt;&lt;/a&gt;Service 和 ServiceHelper&lt;/h3&gt;&lt;p&gt;Service的角色是在activity消失后仍能在后台执行耗时操作。activity来去自由，它仅仅是应用程序的用户界面。用户可以在他执行耗时操作时选择点击主页按钮，点击关闭按钮。而耗时的操作仍在执行，最好的方式是让数据库去存储资源和状态。当你回来的时候，不管发生了什么，你都可以了解到发生了什么。执行了吗？仍在执行中？&lt;/p&gt;
&lt;p&gt;Service内部维护一个任务队列    ，所有的请求通过ServiceHelper加入或者从队列中移除。当Service取出一个任务开始执行时，将任务交给Processor执行，执行完毕后交由Processor执行回调进行数据处理。&lt;/p&gt;
&lt;p&gt;最重要的，当所有的操作完成，关闭service.对其它应用友好，当Service工作完毕，关闭它。&lt;/p&gt;
&lt;h3 id=&quot;Activity&quot;&gt;&lt;a href=&quot;#Activity&quot; class=&quot;headerlink&quot; title=&quot;Activity&quot;&gt;&lt;/a&gt;Activity&lt;/h3&gt;&lt;p&gt;总是记得activities有它们的生命周期，paused, resumed或者destroyed.它们是由用户控制的界面。在onResume方法中我们要在service中增加回调，告诉它我回来了。在onPause移除回调。否则应用迟早会崩溃。&lt;/p&gt;
&lt;p&gt;总是要考虑到一下三种场景：&lt;/p&gt;
&lt;p&gt;activity发出了请求，当activity在前台的时候，一切正常。如果activity发出请求后，activity 暂停，回来，恢复，这时回调执行，你仍然能够执行回调，一切正常。在这种情况下你需要存储请求id,这样就可以询问Service Helper该请求是否正在执行。当执行onResume时回答是“是的，正在执行”。我们只需等待回调执行。&lt;/p&gt;
&lt;p&gt;第三种最复杂，activity paused, request 完成，然后activity resumed.在onResume方法中询问请求是否正在执行，这次的回答是no.那么现在你明白了为什么我选择将响应的结果数据缓存到数据库中了吧。&lt;/p&gt;
&lt;h3 id=&quot;Content-Provider&quot;&gt;&lt;a href=&quot;#Content-Provider&quot; class=&quot;headerlink&quot; title=&quot;Content Provider&quot;&gt;&lt;/a&gt;Content Provider&lt;/h3&gt;&lt;p&gt;Content Provider支持ContentObservers. 当数据库表中的记录变化时，ContentObservers很方便从Content Provider接收到通知.你可以监控到某一个记录，表中的所有记录或者数据库中得所有资源的状态。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/REST&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WIKI&lt;/a&gt; - REST 介绍&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=xHXn3Kg2IQE&amp;amp;list=FLvNeeEPLThnohZqA6_pthkQ&amp;amp;index=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;YouTuBe&lt;/a&gt; - Google IO 大会视频&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是REST&quot;&gt;&lt;a href=&quot;#什么是REST&quot; class=&quot;headerlink&quot; title=&quot;什么是REST?&quot;&gt;&lt;/a&gt;什么是REST?&lt;/h1&gt;&lt;p&gt;含状态传输（英文：Representational State Transfer，简称REST）是一种软件架构风格。需要注意的是，REST是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML以及HTML这些现有的广泛流行的协议和标准。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;资源是由URI来指定。&lt;/li&gt;
&lt;li&gt;对资源的操作包括获取、创建、修改和删除资源，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。&lt;/li&gt;
&lt;li&gt;通过操作资源的表现形式来操作资源。&lt;/li&gt;
&lt;li&gt;资源的表现形式则是XML或者HTML，取决于读者是机器还是人，是消费web服务的客户软件还是web浏览器。当然也可以是任何其他的格式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;REST绝不是只和HTTP相联系.你可以使用任意一种传输协议，但HTTP在REST风格架构中无疑是使用最广泛的。如果我要连接的服务已经有一个适配手机端的web网站，为何我还要开发一个应用呢？换句话说，为什么我们不使用浏览器，一步到位？&lt;/p&gt;
&lt;h1 id=&quot;为什么使用REST&quot;&gt;&lt;a href=&quot;#为什么使用REST&quot; class=&quot;headerlink&quot; title=&quot;为什么使用REST?&quot;&gt;&lt;/a&gt;为什么使用REST?&lt;/h1&gt;&lt;p&gt;好吧，除非浏览器技术发展起来了。我要列举5大原因。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个原因是android应用是集成在android platform中，可以使用intents, content provider等等，浏览器做不到这些。&lt;/li&gt;
&lt;li&gt;正是android平台为android应用提供了一些新功能，你的应用可以为其他应用提供intents.&lt;/li&gt;
&lt;li&gt;你的应用可以在后台运行。这意味着如果要从服务器更新数据，当从服务器取得数据后，应用可以通知用户，让他们知道有数据可用。&lt;/li&gt;
&lt;li&gt;应用和网络的连接稳定性有限。当网络较差时，请求可能失败。而android应用可以在后台进行多次重试，让用户在使用浏览器多次按刷按钮的痛苦中解放出来。&lt;/li&gt;
&lt;li&gt;应用可以将从网络中取得资源，比如JSON, 或者二进制，或者XML格式的内容解析并存储在数据库中。因此，当你想取得新数据时，你就可以选择获取比数据库中数据更新的或者更老旧的数据，而不是和数据库中缓存相同的数据。这样你就不用获得所有html，就不用花长时间去下载javascript.&lt;/li&gt;
&lt;li&gt;最后，你的应用可以和android操作系统在使用上保持一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;新手应该避免的&quot;&gt;&lt;a href=&quot;#新手应该避免的&quot; class=&quot;headerlink&quot; title=&quot;新手应该避免的&quot;&gt;&lt;/a&gt;新手应该避免的&lt;/h1&gt;&lt;p&gt;你是一个Java程序员。翻看了一下Android SDK,你对自己说，“我知道什么是activity,这有什么难的？我将创建一个activity, 知道REST方法执行耗时，因为会连接服务器，所以我会开启一个线程来执行。你决定这个线程是Activity里的内部类，并将取得的数据存储在内存中。&lt;/p&gt;
&lt;p&gt;当你把app跑起来了，它运行得很快，没有崩溃，那么这为什么正确的方法？你得理解Android操作系统是如何工作的，Android操作系统是设计运行在有限资源的设备上的，当系统要启动一个新应用，并且内存不够时，它将决定强制关闭一个已经存在的应用。那么它如何作出这个决定？答案是，你要帮助操作系统做出决定。如果你的应用没有前台运行的activity，不向用户展示，没有执行一些操作，那么就会安全关闭。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何防止内存泄漏</title>
    <link href="http://sonaive.com/2014/08/26/how-to-avoid-memeory-leak/"/>
    <id>http://sonaive.com/2014/08/26/how-to-avoid-memeory-leak/</id>
    <published>2014-08-26T02:53:10.000Z</published>
    <updated>2014-08-26T09:25:40.000Z</updated>
    
    <content type="html">&lt;p&gt;#Memory Leak&lt;/p&gt;
&lt;p&gt;考虑下面的代码块：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SampleActivity&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Activity&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Handler mLeakyHandler = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Handler() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handleMessage&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Message msg)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;也许不是那么明显，这块代码能造成大量的内存溢出。Android Lint 会提示如下警告&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In Android, Handler classes should be static or leaks might occur.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是内存是在哪儿溢出的，是如何发生的？首先通过列出我们已经知道的事实来找问题的根源：&lt;/p&gt;
&lt;p&gt;1.当Android应用程序第一次启动时，framework在应用程序的主线程里创建了一个Looper对象。Looper实现了一个简单的消息队列，依次处理队列里的消息对象。所有的应用程序框架里的事件（比如Activity的生命周期函数调用，按钮点击事件等等）都封装为消息对象，被加入到Looper的消息队列中并依次处理。主线程的Looper在整个应用的生命周期里会一直存在。&lt;/p&gt;
&lt;p&gt;2.当在主线程里实例化一个Handler时，就和Looper的消息队列关联在一起了。发送到消息队列的消息会持有Handler的引用，使得当Looper最后处理消息时候，framework可以调用Handler#handleMessage（Message）.&lt;/p&gt;
&lt;p&gt;3.在Java中，非静态匿名内部类会持有它所在外部类的隐式引用。而静态内部类不会。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;那么到底内存是在什么地方泄漏的?非常巧妙，思考下面一段示例代码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SampleActivity&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Activity&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Handler mLeakyHandler = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Handler() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handleMessage&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Message msg)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Bundle savedInstanceState)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onCreate(savedInstanceState);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Post a message and delay its execution for 10 minutes.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mLeakyHandler.postDelayed(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Runnable() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;, &lt;span class=&quot;number&quot;&gt;60&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Go back to the previous Activity.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        finish();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当activity结束掉，延迟的消息会在主线程的队列中生存10分钟，直到被处理。该消息持有activity &lt;code&gt;Handler&lt;/code&gt;的引用，且&lt;code&gt;Handler&lt;/code&gt;持有外部类的隐式引用（当前情况下是SampleActivity）.该引用会持续存在直到消息被处理，因此妨碍了&lt;code&gt;Activity Context&lt;/code&gt;被垃圾回收，从而导致应用程序资源泄漏。注意在15行的匿名内部类会导致一样的情况。非静态匿名内部类的实例持有它们外部类的的隐式引用，因此&lt;code&gt;Context&lt;/code&gt;会泄漏。&lt;/p&gt;
&lt;p&gt;为了修复这个问题，创建一个类继承&lt;code&gt;Handler&lt;/code&gt;或者使用静态内部类。静态内部类不会持有它的外部类的隐式引用，所以activity不会溢出。如果需要在&lt;code&gt;Handler&lt;/code&gt;中调用外部activity的方法，使&lt;code&gt;Handler&lt;/code&gt;持有activity的&lt;code&gt;WeakReference&lt;/code&gt;,因此不会导致&lt;code&gt;Context&lt;/code&gt;意外溢出。当实例化匿名的&lt;code&gt;Runnable&lt;/code&gt;类时，为了修复内存溢出，为这个类创建一个静态域（因为匿名内部类的静态实例不会持有它的外部类的引用）：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SampleActivity&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Activity&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * Instances of static inner classes do not hold an implicit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * reference to their outer class.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyHandler&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Handler&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; WeakReference&amp;lt;SampleActivity&amp;gt; mActivity;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyHandler&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(SampleActivity activity)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mActivity = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; WeakReference&amp;lt;SampleActivity&amp;gt;(activity);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handleMessage&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Message msg)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            SampleActivity activity = mActivity.get();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (activity != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; MyHandler mHandler = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MyHandler(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * Instances of anonymous classes do not hold an implicit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * reference to their outer class when they are &quot;static&quot;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Runnable sRunnable = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Runnable() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Bundle savedInstanceState)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onCreate(savedInstanceState);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Post a message and delay its execution for 10 minutes.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mHandler.postDelayed(sRunnable, &lt;span class=&quot;number&quot;&gt;60&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Go back to the previous Activity.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        finish();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;静态和非静态内部类之间的区别很微妙，但每个Android程序员都应该理解它。底线是什么？如果内部类的实例比activity的&lt;br&gt;生命周期长，避免在activity中使用非静态内部类。相反，推荐使用静态内部类，持有activity的弱引用。&lt;/p&gt;
&lt;p&gt;以下是原文链接：&lt;br&gt;&lt;a href=&quot;http://www.androiddesignpatterns.com/2013/01/inner-class-handler-memory-leak.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How to Leak a Context: Handlers &amp;amp; Inner Classes&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;#Memory Leak&lt;/p&gt;
&lt;p&gt;考虑下面的代码块：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SampleActivity&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Activity&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Handler mLeakyHandler = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Handler() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handleMessage&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Message msg)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;也许不是那么明显，这块代码能造成大量的内存溢出。Android Lint 会提示如下警告&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In Android, Handler classes should be static or leaks might occur.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是内存是在哪儿溢出的，是如何发生的？首先通过列出我们已经知道的事实来找问题的根源：&lt;/p&gt;
&lt;p&gt;1.当Android应用程序第一次启动时，framework在应用程序的主线程里创建了一个Looper对象。Looper实现了一个简单的消息队列，依次处理队列里的消息对象。所有的应用程序框架里的事件（比如Activity的生命周期函数调用，按钮点击事件等等）都封装为消息对象，被加入到Looper的消息队列中并依次处理。主线程的Looper在整个应用的生命周期里会一直存在。&lt;/p&gt;
&lt;p&gt;2.当在主线程里实例化一个Handler时，就和Looper的消息队列关联在一起了。发送到消息队列的消息会持有Handler的引用，使得当Looper最后处理消息时候，framework可以调用Handler#handleMessage（Message）.&lt;/p&gt;
&lt;p&gt;3.在Java中，非静态匿名内部类会持有它所在外部类的隐式引用。而静态内部类不会。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Loader框架</title>
    <link href="http://sonaive.com/2014/08/25/the-loader-framework/"/>
    <id>http://sonaive.com/2014/08/25/the-loader-framework/</id>
    <published>2014-08-25T03:23:47.000Z</published>
    <updated>2014-08-26T10:39:07.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;Loader-Framework&quot;&gt;&lt;a href=&quot;#Loader-Framework&quot; class=&quot;headerlink&quot; title=&quot;Loader Framework&quot;&gt;&lt;/a&gt;Loader Framework&lt;/h1&gt;&lt;p&gt; 如果在应用里通过ContentProvider取得数据，最糟的情况可能有一下几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;你完全不知道android应用该怎么写，在主线程里去执行耗时操作&lt;/li&gt;
&lt;li&gt;使用AsyncTask:&lt;br&gt;你的app在屏幕方向改变的时候崩溃了，于是你google到stackoverflow上的答案并锁定了屏幕方向，接着你加上了容易出错的代码，在Activity中detach,attach AsyncTask.&lt;/li&gt;
&lt;li&gt;使用CursorLoader&lt;br&gt;从android HoneyComb到Kitkat,Loader Framework中的Loader子类都只有孤零零的CusorLoader.很可能你会使用其他的异步操作，而不仅仅是通过ContentProvider.你也许想要访问SharedPreferences,读文件或者请求访问web API.那样的话，你需要Loader&lt;someotherdatathancursor&gt;,但正确实现它会有点复杂。&lt;br&gt;我将带你完整过一遍整个流程，理解Loaders是如何工作的，为你的Loaders实现一个正确的基类，实现一个修复所有问题的CursorLoader,并扩展使其具备通知多个Uri的能力。这将是一篇长博客，所以拿一杯你喜欢的饮料边看边喝吧。&lt;/someotherdatathancursor&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Loaders&quot;&gt;&lt;a href=&quot;#Loaders&quot; class=&quot;headerlink&quot; title=&quot;Loaders&quot;&gt;&lt;/a&gt;Loaders&lt;/h2&gt;&lt;p&gt;Loader应该要做到三件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在后台线程里加载数据&lt;/li&gt;
&lt;li&gt;缓存已经加载的数据，这样就不会在屏幕方向变化的时候重新加载一遍了。&lt;/li&gt;
&lt;li&gt;如果可行，监控数据源并在适当的时候重新加载最新的数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Loader类自身并没有在后台线程里加载数据的机制，或者你自己实现，或者你继承AsyncTaskLoader.这部分内容就涵盖了我们需求列表第一点。&lt;/p&gt;
&lt;p&gt;AsyncTaskLoader并没有处理好第二点。事实上AsyncTaskLoader远远没有到达功能完全，比如这种看上去非常合理的实现并不能起作用。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;pre&gt;&lt;code&gt;public class DasLoader extends AsyncTaskLoader&amp;lt;String&amp;gt; {
    public DasLoader(Context context) {
        super(context); 
    } 
    @Override public String loadInBackground() { return &amp;quot;Das&amp;quot;; } 
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##AbstractLoader v1##&lt;/p&gt;
&lt;p&gt;下面这种实现提供了所有的加载和缓存数据的模板代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public abstract class AbstractLoader&amp;lt;T&amp;gt; extends AsyncTaskLoader&amp;lt;T&amp;gt; { 
    T mResult; 
    public AbstractLoader(Context context) { 
        super(context); 
    } 

    @Override 
    public void deliverResult(T result) { 
        if (isReset()) { 
            releaseResources(result); 
            return; 
        } 
        T oldResult = mResult; 
        mResult = result; 
        if (isStarted()) { 
            super.deliverResult(result);
        } 
        if (oldResult != result &amp;amp;&amp;amp; oldResult != null) {
            releaseResources(oldResult); 
        }
    }

    @Override 
    public void onCanceled(T result) { 
        super.onCanceled(result); 
        releaseResources(result); 
    }

    @Override 
    protected void onReset() {
        super.onReset(); // Ensure the loader is stopped onStopLoading();
        releaseResources(mResult);
        mResult = null; 
    }

    @Override 
    protected void onStartLoading() { 
        if (mResult != null) { 
            deliverResult(mResult); 
        } 
        if (takeContentChanged() || mResult == null) { 
            forceLoad();
        }
    } 

    @Override
    protected void onStopLoading() { 
        cancelLoad(); 
    }
    protected void releaseResources(T result) { }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;奇怪的是framework没有提供这样的类。而现在你可以像这样写你的自定义Loader.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class DasLoader extends AbstractLoader&amp;lt;String&amp;gt; {
    public DasLoader(Context context) {
        super(context); 
    }
    @Override
    public String loadInBackground() { 
        return &amp;quot;Das&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但为什么需要这些代码？理解Loaders的关键是理解loader行为的不同状态：started,stopped,abandoned和reset。当进入每种状态时，相应的callback就会执行。&lt;/p&gt;
&lt;p&gt;onStartLoading:已经创建Loader,要么加载数据，或者返回已缓存的数据。&lt;/p&gt;
&lt;p&gt;onStopLoading:Loader应该保存缓存的数据，监控数据源变化，但不能加载数据。比如用户回到屏幕桌面，就会发生这种情况。&lt;/p&gt;
&lt;p&gt;onAbandoned:重新启动Loader.在onCreateLoader回调方法里创建了Loader的新实例，并在Fragment或者Activity里加载新数据。在被废弃的Loader里监控数据源或者重新加载数据没有意义–数据会在新Loader里加载。当新Loader发送数据后，这个被废弃的Loader会被重置。&lt;/p&gt;
&lt;p&gt;onReset:Loader加载的之前的数据不会再使用，并会清空。该Loader可能会重新启动，所以在你的Loader实现里清空状态。&lt;/p&gt;
&lt;p&gt;AsyncTaskLoader提供了额外的回调：&lt;/p&gt;
&lt;p&gt;onCancelled:当加载时发现不会再使用该数据会调用，比如当AsyncTask执行onLoadInBackgroud时被取消。在该回调中你应该处理好释放资源。&lt;/p&gt;
&lt;p&gt;因为onRest callback和deliverResults实现中都需要释放资源，我们的AbstractLoader提供了方便的realeaseResources()方法用来关闭Cursor或者文件处理器等等。&lt;/p&gt;
&lt;p&gt;现在梳理一遍AbstractLoader的实现。当使用 LoaderManager.initLoader()启动了Loader，onStartLoading被调用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;T mResult; 
// ... 
@Override 
protected void onStartLoading() {
    if (mResult != null) {             
        deliverResult(mResult);
    } 
    if (takeContentChanged() || mResult == null) { 
        forceLoad();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在AbstractLoader中的mResult成员保存已加载的数据.如果已经加载完数据，只需要将结果传递到Loader 客户端中。如果缓存数据为空，或者Loader被通知有新数据可以获取，就会调用forceLoad()方法强制加载数据。该方法启动AsyncTask在后台线程中调用loadInBackground,最后结果会传给deliverResults方法中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void deliverResult(T result) {
    if (isReset()) {
        releaseResources(result);     
        return; 
    }
    T oldResult = mResult; 
    mResult = result; 
    if (isStarted()) {
        super.deliverResult(result);
    } 
    if (oldResult != result &amp;amp;&amp;amp; oldResult != null) { 
        releaseResources(oldResult);
    } 
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这块有些有趣的事情。首先，检查loader是否进入reset状态。该状态中之前所有的资源都要是否，所以只需要处理新加载的数据。然后将数据交换到缓存中，调用deliverResults，释放之前缓存的资源。&lt;/p&gt;
&lt;p&gt;当Fragment或者Activity中活动的Loader停止了，Loaders仍然要进入到stop状态。这意味着Loaders需要保持缓存数据，监控数据是否有效，但是不能加载数据或者将数据传递到UI线程中。按照AsyncTaskLoader，意味着取消所有运行的AsyncTasks.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override 
protected void onStopLoading() {
    cancelLoad();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;目前AsyncTaskLoader的实现并没有打断当前的任务，只保证了这些任务的结果不会传递到UI线程中。然而，这些任务执行的结果需要释放资源，所以onCancelled回调将执行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void onCanceled(T result) {
    super.onCanceled(result);
    releaseResources(result);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后需要实现的都回调是onReset:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override 
protected void onReset() {
    super.onReset(); // Ensure the loader is stopped 
    onStopLoading();
    releaseResources(mResult);
    mResult = null;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这儿有两件重要的事。第一，Loader可以从started状态转换到reset状态，意味着它仍然可有活动的AsyncTasks执行loadInBackgroud.我们需要先将其停止。然后，根据约定，需要释放资源并清空缓存。&lt;/p&gt;
&lt;p&gt;onAbandoned 回调呢？AbstractLoader 自己没有监控数据源，所以这个回调不必实现。&lt;/p&gt;
&lt;p&gt;##CursorLoader##&lt;/p&gt;
&lt;p&gt;那么我们如何能实现观测数据源并自动重新加载的Loader呢？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MyCursorLoader extends AbstractLoader&amp;lt;Cursor&amp;gt; { 
    private final ForceLoadContentObserver mObserver; 

    public MyCursorLoader(Context context) { 
        super(context);
        mObserver = new ForceLoadContentObserver();
    } 
    // bunch of setters for uri, projection, selection, etc. Omitted for brevity 

    @Override 
    public Cursor loadInBackground() {
        Cursor cursor = getContext().getContentResolver().query(mUri, mProjection, mSelection, mSelectionArgs, mSortOrder); 
        if (cursor != null) {
            // Ensure the cursor window is filled
            cursor.getCount(); 
            cursor.registerContentObserver(mObserver); 
        } 
        return cursor;
    } 
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该实现有两个bug,其中一个是功能性bug.让我们着手后一个吧。&lt;/p&gt;
&lt;p&gt;onStartLoading 当进入到该状态时，监控数据源。但想一想，如果查询需要200ms,而数据每150ms发生变化，那将会怎样？Loader将永远不能将数据发送出去，因为每个load请求将会在loadInBackgroud执行的过程中被content observer取消。&lt;/p&gt;
&lt;p&gt;我猜大概就是这个原因，CursorLoader的Android实现在数据加载完成时注册observer.采用这种方法，第一次加载的数据将会尽快发送出去，但接下来加载的数据只会在加载过程中数据源不发生变化时才能发送出去。&lt;/p&gt;
&lt;p&gt;##Fixing CursorLoader##&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当第一次加载的数据发送完毕，注册ContentObserver.&lt;/li&gt;
&lt;li&gt;在onAbandon方法里取消注册ContentObserver.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一点要求我们改变deliverResult方法，因此我们这样来修改AbstractLoader:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override 
public void deliverResult(T result) {
    if (isReset()) {
        releaseResources(result);
        return; 
    } 
    T oldResult = mResult; 
    mResult = result; 
    if (isStarted()) { 
        if (oldResult != result) {
            onNewDataDelivered(result);
        } 
        super.deliverResult(result); 
    } 
    if (oldResult != result &amp;amp;&amp;amp; oldResult != null) { 
        releaseResources(oldResult); 
    } 
} 
protected void onNewDataDelivered(T data) { }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;CursorLoader看起来应该像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MyCursorLoader extends AbstractLoader&amp;lt;Cursor&amp;gt; {  

    private final ForceLoadContentObserver mObserver; 

    public MyCursorLoader(Context context) {
        super(context);
        mObserver = new ForceLoadContentObserver();
    } 
    // bunch of setters for uri, projection, selection, etc. Omitted for brevity 
    @Override 
    public Cursor loadInBackground() { 
        Cursor cursor = getContext().getContentResolver().query(mUri, mProjection, mSelection, mSelectionArgs, mSortOrder); 
        if (cursor != null) { 
            // Ensure the cursor window is filled
            cursor.getCount(); 
        } 
        return cursor; 
    } 
    @Override
    protected void onNewDataDelivered(Cursor data) {
        super.onNewDataDelivered(data);
        data.registerContentObserver(mObserver);
    } 
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第二部分–在onAbandon里取消注册observer会有点困难。如果observer没有注册，调用Cursor.unregisterContentObserver是非法的，而且当deliverResults没被调用的时候onAbandon可以被调用。于是，我们创建一个代理的ContentObserver。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class DisableableContentObserver extends ContentObserver {
    private final ContentObserver mWrappedObserver; 
    private boolean mIsEnabled = true;
    public DisableableContentObserver(ContentObserver wrappedObserver) {

        super(new Handler());
        mWrappedObserver = wrappedObserver;
    } 

    @Override 
    public void onChange(boolean selfChange) {
        if (mIsEnabled) { 
            mWrappedObserver.onChange(selfChange); 
        } 
    } 

    public void setEnabled(boolean isEnabled) { 
        mIsEnabled = isEnabled; 
    }
}


public class MyCursorLoader extends AbstractLoader&amp;lt;Cursor&amp;gt; {

    private final DisableableContentObserver mObserver;
    public MyCursorLoader(Context context) {
        super(context);
        mObserver = new DisableableContentObserver(new ForceLoadContentObserver());
    }
    // bunch of setters for uri, projection, selection, etc. Omitted for brevity
    @Override
    protected void onStartLoading() {
        mObserver.setEnabled(true);
        super.onStartLoading();
    }

    @Override
    protected void onAbandon() {
        mObserver.setEnabled(false);
    }

    @Override
    protected void onReset() {
        mObserver.setEnabled(false);
        super.onReset();
    }

    @Override
    public Cursor loadInBackground() {
        Cursor cursor = getContext().getContentResolver().query(mUri, mProjection, mSelection,
        mSelectionArgs, mSortOrder);
        if (cursor != null) {
            // Ensure the cursor window is filled
            cursor.getCount();
        }
        return cursor;
    }

    @Override
    protected void onNewDataDelivered(Cursor data) {
        super.onNewDataDelivered(data);
        data.registerContentObserver(mObserver);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##AbstractObservingLoader##&lt;br&gt;The CursorLoader is a bit special case, because the Cursor itself contains ContentObservable. In most cases however the content observers and loaded data would be completely separated. For these cases it would be useful to have a base class for Loader which registers some ContentObservers:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public abstract class AbstractObservingLoader&amp;lt;T&amp;gt; extends AbstractLoader&amp;lt;T&amp;gt; {
    protected final DisableableContentObserver mObserver;
    private boolean mIsRegistered;

    public AbstractObservingLoader(Context context) {
        super(context);
        mObserver = new DisableableContentObserver(new ForceLoadContentObserver());
    }

    @Override
    protected void onStartLoading() {
        mObserver.setEnabled(true);
        super.onStartLoading();
    }

    @Override
    protected void onAbandon() {
        mObserver.setEnabled(false);
        unregisterObserver(mObserver);
        mIsRegistered = false;
    }

    @Override
    protected void onReset() {
        mObserver.setEnabled(false);
        unregisterObserver(mObserver);
        mIsRegistered = false;z
        super.onReset();
    }

    @Override
    protected void onNewDataDelivered(T data) {
        if (!mIsRegistered) {
            mIsRegistered = true;
            registerObserver(mObserver);
        }
    }

    protected abstract void registerObserver(ContentObserver observer);
    protected abstract void unregisterObserver(ContentObserver observer);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We need to keep the registered state in our Loader, because the default Observable implementation doesn’t like registering the same observer twice or unregistering not registered observer.&lt;br&gt;Now we can use this class as a base for a Loader which should be reloaded when one of specified Uris is triggered:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MyCursorLoader extends AbstractObservingLoader&amp;lt;Cursor&amp;gt; {

    public MyCursorLoader(Context context) {
        super(context);
    }

    // bunch of setters for uri, projection, selection, etc. Omitted for brevity

    @Override
    public Cursor loadInBackground() {
        Cursor cursor = getContext().getContentResolver().query(mUri, mProjection, mSelection,
        mSelectionArgs, mSortOrder);
        if (cursor != null) {
            // Ensure the cursor window is filled
            cursor.getCount();
        }
        return cursor;
    }

    @Override
    protected void onNewDataDelivered(Cursor data) {
        super.onNewDataDelivered(data);
        data.registerContentObserver(mObserver);
    }

    @Override
    protected void registerObserver(ContentObserver observer) {
        for (Uri uri : mObservedUris) {
            getContext().getContentResolver().registerContentObserver(uri, true, observer);
        }
    }

    @Override
    protected void unregisterObserver(ContentObserver observer) {
        getContext().getContentResolver().unregisterContentObserver(observer);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以下是原文链接：&lt;br&gt;&lt;a href=&quot;http://chalup.github.io/blog/2014/06/12/android-loaders/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;android loaders&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Loader-Framework&quot;&gt;&lt;a href=&quot;#Loader-Framework&quot; class=&quot;headerlink&quot; title=&quot;Loader Framework&quot;&gt;&lt;/a&gt;Loader Framework&lt;/h1&gt;&lt;p&gt; 如果在应用里通过ContentProvider取得数据，最糟的情况可能有一下几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;你完全不知道android应用该怎么写，在主线程里去执行耗时操作&lt;/li&gt;
&lt;li&gt;使用AsyncTask:&lt;br&gt;你的app在屏幕方向改变的时候崩溃了，于是你google到stackoverflow上的答案并锁定了屏幕方向，接着你加上了容易出错的代码，在Activity中detach,attach AsyncTask.&lt;/li&gt;
&lt;li&gt;使用CursorLoader&lt;br&gt;从android HoneyComb到Kitkat,Loader Framework中的Loader子类都只有孤零零的CusorLoader.很可能你会使用其他的异步操作，而不仅仅是通过ContentProvider.你也许想要访问SharedPreferences,读文件或者请求访问web API.那样的话，你需要Loader&lt;SomeOtherDataThanCursor&gt;,但正确实现它会有点复杂。&lt;br&gt;我将带你完整过一遍整个流程，理解Loaders是如何工作的，为你的Loaders实现一个正确的基类，实现一个修复所有问题的CursorLoader,并扩展使其具备通知多个Uri的能力。这将是一篇长博客，所以拿一杯你喜欢的饮料边看边喝吧。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Loaders&quot;&gt;&lt;a href=&quot;#Loaders&quot; class=&quot;headerlink&quot; title=&quot;Loaders&quot;&gt;&lt;/a&gt;Loaders&lt;/h2&gt;&lt;p&gt;Loader应该要做到三件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在后台线程里加载数据&lt;/li&gt;
&lt;li&gt;缓存已经加载的数据，这样就不会在屏幕方向变化的时候重新加载一遍了。&lt;/li&gt;
&lt;li&gt;如果可行，监控数据源并在适当的时候重新加载最新的数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Loader类自身并没有在后台线程里加载数据的机制，或者你自己实现，或者你继承AsyncTaskLoader.这部分内容就涵盖了我们需求列表第一点。&lt;/p&gt;
&lt;p&gt;AsyncTaskLoader并没有处理好第二点。事实上AsyncTaskLoader远远没有到达功能完全，比如这种看上去非常合理的实现并不能起作用。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>搭建我的 github + octopress 博客</title>
    <link href="http://sonaive.com/2014/07/28/build-blog-with-github-plus-octopress/"/>
    <id>http://sonaive.com/2014/07/28/build-blog-with-github-plus-octopress/</id>
    <published>2014-07-28T13:00:27.000Z</published>
    <updated>2014-08-26T02:14:18.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;使用-Github-Octopress-搭建博客&quot;&gt;&lt;a href=&quot;#使用-Github-Octopress-搭建博客&quot; class=&quot;headerlink&quot; title=&quot;使用 Github+Octopress 搭建博客&quot;&gt;&lt;/a&gt;使用 Github+Octopress 搭建博客&lt;/h1&gt;&lt;h2 id=&quot;1-对git不陌生&quot;&gt;&lt;a href=&quot;#1-对git不陌生&quot; class=&quot;headerlink&quot; title=&quot;1.对git不陌生&quot;&gt;&lt;/a&gt;1.对git不陌生&lt;/h2&gt;&lt;h2 id=&quot;2-创建github页面。注意：&quot;&gt;&lt;a href=&quot;#2-创建github页面。注意：&quot; class=&quot;headerlink&quot; title=&quot;2.创建github页面。注意：&quot;&gt;&lt;/a&gt;2.创建github页面。注意：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Github Pages for users and organizations uses the master branch like the public directory on a web server, serving up the files at your Pages url &lt;a href=&quot;http://username.github.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://username.github.io&lt;/a&gt;. As a result, you’ll want to work on the source for your blog in the source branch and commit the generated content to the master branch. Octopress has a configuration task that helps you set all this up.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如我的github用户名是taoliuh,那么创建一个github page 一定要设置仓库名称为taoliuh.github.io&lt;/p&gt;
&lt;h2 id=&quot;3-绑定独立域名&quot;&gt;&lt;a href=&quot;#3-绑定独立域名&quot; class=&quot;headerlink&quot; title=&quot;3.绑定独立域名&quot;&gt;&lt;/a&gt;3.绑定独立域名&lt;/h2&gt;&lt;p&gt;我在godaddy上注册的域名。在域名管理页面添加ANAME： @204.232.175.78 CNAME： http your-custom-domain&lt;/p&gt;
&lt;h2 id=&quot;4-发表博客&quot;&gt;&lt;a href=&quot;#4-发表博客&quot; class=&quot;headerlink&quot; title=&quot;4.发表博客&quot;&gt;&lt;/a&gt;4.发表博客&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;rake new_post[&amp;quot;Hello World: The First of Many New Blog Posts&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;5-预览&quot;&gt;&lt;a href=&quot;#5-预览&quot; class=&quot;headerlink&quot; title=&quot;5.预览&quot;&gt;&lt;/a&gt;5.预览&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;rake preview
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;6-发布&quot;&gt;&lt;a href=&quot;#6-发布&quot; class=&quot;headerlink&quot; title=&quot;6.发布&quot;&gt;&lt;/a&gt;6.发布&lt;/h2&gt;&lt;p&gt;当完成写作时，你需要生成并发布到github.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rake generate
rake deploy
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不要忘了提交改动的文件到source分支&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add . 
git commit -am &amp;apos;Add my first blog post&amp;apos; 
git push origin source
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在你就能在这个页面user-name.github.io看到你的博客文章了～LOL&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;a href=&quot;https://pages.github.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;设置github page&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://robdodson.me/blog/2012/04/30/custom-domain-with-octopress-and-github-pages/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Custom Domain With Octopress and Github Pages&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://beyondvincent.com/blog/2013/07/27/107-hello-page-of-github/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;你好！github页面&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://yanping.me/cn/blog/2012/01/07/theming-and-customization/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;为Octopress修改主题和自定义样式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://biaobiaoqi.me/blog/2013/07/10/decorate-octopress/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;定制Octopress&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;象写程序一样写博客：搭建基于github的博客&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用-Github-Octopress-搭建博客&quot;&gt;&lt;a href=&quot;#使用-Github-Octopress-搭建博客&quot; class=&quot;headerlink&quot; title=&quot;使用 Github+Octopress 搭建博客&quot;&gt;&lt;/a&gt;使用 Github+Octopress 搭建博客&lt;/h1&gt;&lt;h2 id=&quot;1-对git不陌生&quot;&gt;&lt;a href=&quot;#1-对git不陌生&quot; class=&quot;headerlink&quot; title=&quot;1.对git不陌生&quot;&gt;&lt;/a&gt;1.对git不陌生&lt;/h2&gt;&lt;h2 id=&quot;2-创建github页面。注意：&quot;&gt;&lt;a href=&quot;#2-创建github页面。注意：&quot; class=&quot;headerlink&quot; title=&quot;2.创建github页面。注意：&quot;&gt;&lt;/a&gt;2.创建github页面。注意：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Github Pages for users and organizations uses the master branch like the public directory on a web server, serving up the files at your Pages url &lt;a href=&quot;http://username.github.io&quot;&gt;http://username.github.io&lt;/a&gt;. As a result, you’ll want to work on the source for your blog in the source branch and commit the generated content to the master branch. Octopress has a configuration task that helps you set all this up.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如我的github用户名是taoliuh,那么创建一个github page 一定要设置仓库名称为taoliuh.github.io&lt;/p&gt;
&lt;h2 id=&quot;3-绑定独立域名&quot;&gt;&lt;a href=&quot;#3-绑定独立域名&quot; class=&quot;headerlink&quot; title=&quot;3.绑定独立域名&quot;&gt;&lt;/a&gt;3.绑定独立域名&lt;/h2&gt;&lt;p&gt;我在godaddy上注册的域名。在域名管理页面添加ANAME： @204.232.175.78 CNAME： http your-custom-domain&lt;/p&gt;
&lt;h2 id=&quot;4-发表博客&quot;&gt;&lt;a href=&quot;#4-发表博客&quot; class=&quot;headerlink&quot; title=&quot;4.发表博客&quot;&gt;&lt;/a&gt;4.发表博客&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;rake new_post[&amp;quot;Hello World: The First of Many New Blog Posts&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;5-预览&quot;&gt;&lt;a href=&quot;#5-预览&quot; class=&quot;headerlink&quot; title=&quot;5.预览&quot;&gt;&lt;/a&gt;5.预览&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;rake preview
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;6-发布&quot;&gt;&lt;a href=&quot;#6-发布&quot; class=&quot;headerlink&quot; title=&quot;6.发布&quot;&gt;&lt;/a&gt;6.发布&lt;/h2&gt;&lt;p&gt;当完成写作时，你需要生成并发布到github.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rake generate
rake deploy
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不要忘了提交改动的文件到source分支&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add . 
git commit -am &amp;apos;Add my first blog post&amp;apos; 
git push origin source
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在你就能在这个页面user-name.github.io看到你的博客文章了～LOL&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
