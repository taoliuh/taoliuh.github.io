<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>如何构建一个REST客户端 | So Naive</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="什么是REST?含状态传输（英文：Representational State Transfer，简称REST）是一种软件架构风格。需要注意的是，REST是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML以及HTML这些现有的广泛流行的协议和标准。

资源是由URI来指定。
对资源的操作包括获取、创建、修改和删除资源，这些操作正好对应HTTP协议提供的GET、POST、PUT和D">
<meta property="og:type" content="article">
<meta property="og:title" content="如何构建一个REST客户端">
<meta property="og:url" content="http://sonaive.com/2014/11/07/how-to-build-rest-client/index.html">
<meta property="og:site_name" content="So Naive">
<meta property="og:description" content="什么是REST?含状态传输（英文：Representational State Transfer，简称REST）是一种软件架构风格。需要注意的是，REST是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML以及HTML这些现有的广泛流行的协议和标准。

资源是由URI来指定。
对资源的操作包括获取、创建、修改和删除资源，这些操作正好对应HTTP协议提供的GET、POST、PUT和D">
<meta property="og:image" content="http://sonaive.com/assets/img/incorrect_implement.png">
<meta property="og:image" content="http://sonaive.com/assets/img/option-A-use-service-api.png">
<meta property="og:updated_time" content="2016-04-01T09:18:56.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="如何构建一个REST客户端">
<meta name="twitter:description" content="什么是REST?含状态传输（英文：Representational State Transfer，简称REST）是一种软件架构风格。需要注意的是，REST是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML以及HTML这些现有的广泛流行的协议和标准。

资源是由URI来指定。
对资源的操作包括获取、创建、修改和删除资源，这些操作正好对应HTTP协议提供的GET、POST、PUT和D">
<meta name="twitter:image" content="http://sonaive.com/assets/img/incorrect_implement.png">
  
    <link rel="alternative" href="/atom.xml" title="So Naive" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/assets/img/avatar.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">So Naive</a></h1>
		</hgroup>

		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/about/">关于我</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/taoliuh" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/u/3190235471?is_all=1" title="weibo">weibo</a>
					        
						</div>
					</nav>
				</section>
				
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">So Naive</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img src="/assets/img/avatar.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
			</div>
			<hgroup>
			  <h1 class="header-author">So Naive</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/about/">关于我</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/taoliuh" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/3190235471?is_all=1" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-how-to-build-rest-client" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/11/07/how-to-build-rest-client/" class="article-date">
  	<time datetime="2014-11-07T04:11:44.000Z" itemprop="datePublished">2014-11-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      如何构建一个REST客户端
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="什么是REST"><a href="#什么是REST" class="headerlink" title="什么是REST?"></a>什么是REST?</h1><p>含状态传输（英文：Representational State Transfer，简称REST）是一种软件架构风格。需要注意的是，REST是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML以及HTML这些现有的广泛流行的协议和标准。</p>
<ul>
<li>资源是由URI来指定。</li>
<li>对资源的操作包括获取、创建、修改和删除资源，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。</li>
<li>通过操作资源的表现形式来操作资源。</li>
<li>资源的表现形式则是XML或者HTML，取决于读者是机器还是人，是消费web服务的客户软件还是web浏览器。当然也可以是任何其他的格式</li>
</ul>
<p>REST绝不是只和HTTP相联系.你可以使用任意一种传输协议，但HTTP在REST风格架构中无疑是使用最广泛的。如果我要连接的服务已经有一个适配手机端的web网站，为何我还要开发一个应用呢？换句话说，为什么我们不使用浏览器，一步到位？</p>
<h1 id="为什么使用REST"><a href="#为什么使用REST" class="headerlink" title="为什么使用REST?"></a>为什么使用REST?</h1><p>好吧，除非浏览器技术发展起来了。我要列举5大原因。</p>
<ul>
<li>第一个原因是android应用是集成在android platform中，可以使用intents, content provider等等，浏览器做不到这些。</li>
<li>正是android平台为android应用提供了一些新功能，你的应用可以为其他应用提供intents.</li>
<li>你的应用可以在后台运行。这意味着如果要从服务器更新数据，当从服务器取得数据后，应用可以通知用户，让他们知道有数据可用。</li>
<li>应用和网络的连接稳定性有限。当网络较差时，请求可能失败。而android应用可以在后台进行多次重试，让用户在使用浏览器多次按刷按钮的痛苦中解放出来。</li>
<li>应用可以将从网络中取得资源，比如JSON, 或者二进制，或者XML格式的内容解析并存储在数据库中。因此，当你想取得新数据时，你就可以选择获取比数据库中数据更新的或者更老旧的数据，而不是和数据库中缓存相同的数据。这样你就不用获得所有html，就不用花长时间去下载javascript.</li>
<li>最后，你的应用可以和android操作系统在使用上保持一致性。<a id="more"></a>
</li>
</ul>
<h1 id="新手应该避免的"><a href="#新手应该避免的" class="headerlink" title="新手应该避免的"></a>新手应该避免的</h1><p>你是一个Java程序员。翻看了一下Android SDK,你对自己说，“我知道什么是activity,这有什么难的？我将创建一个activity, 知道REST方法执行耗时，因为会连接服务器，所以我会开启一个线程来执行。你决定这个线程是Activity里的内部类，并将取得的数据存储在内存中。</p>
<p>当你把app跑起来了，它运行得很快，没有崩溃，那么这为什么正确的方法？你得理解Android操作系统是如何工作的，Android操作系统是设计运行在有限资源的设备上的，当系统要启动一个新应用，并且内存不够时，它将决定强制关闭一个已经存在的应用。那么它如何作出这个决定？答案是，你要帮助操作系统做出决定。如果你的应用没有前台运行的activity，不向用户展示，没有执行一些操作，那么就会安全关闭。</p>
<img src="/assets/img/incorrect_implement.png" title="[The Incorrect Implementation of REST Methods]">  
<p>上图有什么问题呢？比如有这样一个场景：<br>启动线程执行REST方法，这时来了一个电话，当前activity状态为paused,这时操作系统说，这个进程没有前台的activity,所以我要杀死它，让它强制关闭。你猜会发生什么，提交的POST, PUT, DELETE方法也许就在服务器上执行，但是你的app永远也不会了解到执行结果。你执行了GET方法，获取到所有的数据，解析，you’re happy.操作系统却关闭了它。浪费带宽。你的方法存在的另一个问题是将数据存放在内存中。等等，这样运行的会快。至于为什么这么做不好，是因为你得不停从服务器获取数据，因为用户重启了设备，或者某个时间点进程被强制关闭了，浪费了CPU,电池电量，网络带宽。这不是写android应用的好方式。至于某些人说，从内存取数据要快得多，我要说，使用Content Provider,你可以将数据缓存到内存中。所以这都不是理由。</p>
<h1 id="三种正确的设计模式"><a href="#三种正确的设计模式" class="headerlink" title="三种正确的设计模式"></a>三种正确的设计模式</h1><p>google工程师在2011年的IO大会讲了三种设计模式，会带来最好的用户体验及最高的性能。一种是基于Service API,一种是基于Content Provider API,第三种使用Sync Adapter，是第二种的变种。这里只讨论第一种：</p>
<img src="/assets/img/option-A-use-service-api.png" title="[Option A: Use a Service API]">
<h2 id="由底至上"><a href="#由底至上" class="headerlink" title="由底至上"></a>由底至上</h2><h3 id="REST-METHOD"><a href="#REST-METHOD" class="headerlink" title="REST METHOD"></a>REST METHOD</h3><p>什么是REST METHOD？很简单，REST METHOD是具备这种能力的实体，准备HTTP URL,在某些情况下准备HTTP body,和服务器进行HTTP传输，处理响应数据。</p>
<h3 id="Processor"><a href="#Processor" class="headerlink" title="Processor"></a>Processor</h3><p>Processor的角色是将服务器资源映射到本地数据库中。我们需要往数据库中插入一条记录，该记录至少有两个字段，status column和result column. status列指示资源的状态。因为当执行REST方法时每种资源都具有传输状态。当资源正在传输过程中，资源没有和服务器成功同步，所以需要跟踪资源的状态。两方面原因：用户界面可能想要显示资源的某种状态，在同步的过程中，用户可能会离开当前activity。而你可以提醒用户说：“我正在同步资源，请继续使用app,当任务完成时我会通知你”。当该界面状态消失时，说明资源已经同步完毕。</p>
<p>因此status会保存一些标志。“我正在执行POST METHOD”, “我正在执行UPDATING”, “DELETING”.于是在任何时候，你只需要检查数据库就可以知道资源的状态。result列保存最后一次REST方法执行后的HTTP响应数据。</p>
<p>Processor在REST METHOD执行的前后都执行一次。当和服务器交互完毕，更新状态标记。</p>
<p>顺便说一句，这些标记可以用作其他用途。当你需要重试之前失败的操作怎么办？而知道将要进行的操作是不是很棒？posting标记告诉你需要执行POST METHOD.查看传输状态标记，是否有一个HTTP传输正在POST,如果有将不会开始一个新的请求。否则的话我可以选择重试。</p>
<p>还要提一句，用于不要在主线程中执行数据库操作或者Content Provider操作，可能会带来ANR.</p>
<h3 id="Service-和-ServiceHelper"><a href="#Service-和-ServiceHelper" class="headerlink" title="Service 和 ServiceHelper"></a>Service 和 ServiceHelper</h3><p>Service的角色是在activity消失后仍能在后台执行耗时操作。activity来去自由，它仅仅是应用程序的用户界面。用户可以在他执行耗时操作时选择点击主页按钮，点击关闭按钮。而耗时的操作仍在执行，最好的方式是让数据库去存储资源和状态。当你回来的时候，不管发生了什么，你都可以了解到发生了什么。执行了吗？仍在执行中？</p>
<p>Service内部维护一个任务队列    ，所有的请求通过ServiceHelper加入或者从队列中移除。当Service取出一个任务开始执行时，将任务交给Processor执行，执行完毕后交由Processor执行回调进行数据处理。</p>
<p>最重要的，当所有的操作完成，关闭service.对其它应用友好，当Service工作完毕，关闭它。</p>
<h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><p>总是记得activities有它们的生命周期，paused, resumed或者destroyed.它们是由用户控制的界面。在onResume方法中我们要在service中增加回调，告诉它我回来了。在onPause移除回调。否则应用迟早会崩溃。</p>
<p>总是要考虑到一下三种场景：</p>
<p>activity发出了请求，当activity在前台的时候，一切正常。如果activity发出请求后，activity 暂停，回来，恢复，这时回调执行，你仍然能够执行回调，一切正常。在这种情况下你需要存储请求id,这样就可以询问Service Helper该请求是否正在执行。当执行onResume时回答是“是的，正在执行”。我们只需等待回调执行。</p>
<p>第三种最复杂，activity paused, request 完成，然后activity resumed.在onResume方法中询问请求是否正在执行，这次的回答是no.那么现在你明白了为什么我选择将响应的结果数据缓存到数据库中了吧。</p>
<h3 id="Content-Provider"><a href="#Content-Provider" class="headerlink" title="Content Provider"></a>Content Provider</h3><p>Content Provider支持ContentObservers. 当数据库表中的记录变化时，ContentObservers很方便从Content Provider接收到通知.你可以监控到某一个记录，表中的所有记录或者数据库中得所有资源的状态。</p>
<p><a href="http://zh.wikipedia.org/wiki/REST" target="_blank" rel="external">WIKI</a> - REST 介绍</p>
<p><a href="https://www.youtube.com/watch?v=xHXn3Kg2IQE&amp;list=FLvNeeEPLThnohZqA6_pthkQ&amp;index=1" target="_blank" rel="external">YouTuBe</a> - Google IO 大会视频</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/03/30/image-loader-in-cube-sdk_1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          浅析Cube SDK里的ImageLoader组件是如何加载图片的（一）
        
      </div>
    </a>
  
  
    <a href="/2014/08/26/how-to-avoid-memeory-leak/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">如何防止内存泄漏</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="how-to-build-rest-client" data-title="如何构建一个REST客户端" data-url="http://sonaive.com/2014/11/07/how-to-build-rest-client/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 So Naive
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: false,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>